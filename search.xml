<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android中关于存贮的类的详解]]></title>
    <url>%2F2018%2F03%2F05%2FAndroid%E4%B8%AD%E5%85%B3%E4%BA%8E%E5%AD%98%E8%B4%AE%E7%9A%84%E7%B1%BB%E7%9A%84%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Android开发中Environment类的探究和学习参考的博客：http://blog.csdn.net/android_dong/article/details/38686283 比较高深的一片：http://blog.csdn.net/u012889434/article/details/45578059 http://blog.csdn.net/wangsf1112/article/details/51427007 大牛的文章:http://gityuan.com/2016/07/23/android-io-arch/ 在使用Encironment类进行外部存储的时候，需要判断外部设备是不是可以使用； getExternalStorageState（）；//来获取外部设备的存储的状态 下面是Envrionment类中关于外部存储设备的状态的定义： /** * Unknown storage state, such as when a path isn&apos;t backed by known storage * media.（未知的存储状态，如路径不支持已知存储媒体。） */ public static final String MEDIA_UNKNOWN = &quot;unknown&quot;; /** * Storage state if the media is not present.（存储状态如果媒体不存在。） */ public static final String MEDIA_REMOVED = &quot;removed&quot;; /** * Storage state if the media is present but not mounted.(存储状态,如果设备存在但是没有挂载) */ public static final String MEDIA_UNMOUNTED = &quot;unmounted&quot;; /** * Storage state if the media is present and being disk-checked.(存储状态如果媒体存在并且被磁盘检查。) */ public static final String MEDIA_CHECKING = &quot;checking&quot;; /** * Storage state if the media is present but is blank or is using an * unsupported filesystem.(存储状态如果媒体存在，但是空白或正在使用一个不支持的文件系统。) */ public static final String MEDIA_NOFS = &quot;nofs&quot;; /** * Storage state if the media is present and mounted at its mount point with * read/write access.(存储状态，如果介质存在，并在它的挂载点上安装读/写访问。) */ public static final String MEDIA_MOUNTED = &quot;mounted&quot;; /** * Storage state if the media is present and mounted at its mount point with * read-only access.(存储状态，如果媒体存在并在其挂载点上使用只读访问) */ public static final String MEDIA_MOUNTED_READ_ONLY = &quot;mounted_ro&quot;; /** * Storage state if the media is present not mounted, and shared via USB * mass storage.(存储状态如果媒体没有挂载，并且通过USB存储进行共享。) */ public static final String MEDIA_SHARED = &quot;shared&quot;; /** * Storage state if the media was removed before it was unmounted.(存储状态，如果媒体在卸载之前被删除。) */ public static final String MEDIA_BAD_REMOVAL = &quot;bad_removal&quot;; /** * Storage state if the media is present but cannot be mounted. Typically * this happens if the file system on the media is corrupted.(存储状态如果媒体存在，但不能挂载。通常情况下，如果媒体上的文件系统被破坏了。) */ public static final String MEDIA_UNMOUNTABLE = &quot;unmountable&quot;; /** * Storage state if the media is in the process of being ejected.(存储状态如果媒体处于被弹出的过程中。) */ public static final String MEDIA_EJECTING = &quot;ejecting&quot;; 具体代码如下： //在获取外置的设备的存贮的路劲的时候需要先判断外部存贮的是否可用（挂载和可以使用的状态） String exStorageState = Environment.getExternalStorageState(); // 获取外部设备的状态 if (exStorageState == null || exStorageState.equals(Environment.MEDIA_MOUNTED) || exStorageState.equals(Environment.MEDIA_MOUNTED_READ_ONLY)) { Environment.getExternalStorageDirectory();// 这样一般获取的是 /storage/emulated/0 } 我们看看Envrionment的获取存储路劲的方法的运行过程; // 在Envrionment中的方法 public static File getExternalStorageDirectory() { throwIfUserRequired(); return sCurrentUser.getExternalDirs()[0]; } 我们看一个定义: private static UserEnvironment sCurrentUser; 这个类型是UserEnvrionment类型的,我们看看这个类.这个类是定义在Envrionment内部的一个类;我们直接在源码上边看边解释 /** {@hide} */ //我们可以看到对外是隐藏的 public static class UserEnvironment { private final int mUserId; public UserEnvironment(int userId) { mUserId = userId; } public File[] getExternalDirs() { //关键的方法StorageManager后面还会使用到 volume是指(卷) final StorageVolume[] volumes = StorageManager.getVolumeList(mUserId, StorageManager.FLAG_FOR_WRITE); final File[] files = new File[volumes.length]; for (int i = 0; i &lt; volumes.length; i++) { // 开始循环遍历获取的卷的列表 files[i] = volumes[i].getPathFile(); } return files; } // 下面的是提供的方法,暂时不去细看实现过程. 你可以看到调用的是上面方法了! @Deprecated public File getExternalStorageDirectory() { return getExternalDirs()[0]; } @Deprecated public File getExternalStoragePublicDirectory(String type) { return buildExternalStoragePublicDirs(type)[0]; } public File[] buildExternalStoragePublicDirs(String type) { return buildPaths(getExternalDirs(), type); } public File[] buildExternalStorageAndroidDataDirs() { return buildPaths(getExternalDirs(), DIR_ANDROID, DIR_DATA); } public File[] buildExternalStorageAndroidObbDirs() { return buildPaths(getExternalDirs(), DIR_ANDROID, DIR_OBB); } public File[] buildExternalStorageAppDataDirs(String packageName) { return buildPaths(getExternalDirs(), DIR_ANDROID, DIR_DATA, packageName); } public File[] buildExternalStorageAppMediaDirs(String packageName) { return buildPaths(getExternalDirs(), DIR_ANDROID, DIR_MEDIA, packageName); } public File[] buildExternalStorageAppObbDirs(String packageName) { return buildPaths(getExternalDirs(), DIR_ANDROID, DIR_OBB, packageName); } public File[] buildExternalStorageAppFilesDirs(String packageName) { return buildPaths(getExternalDirs(), DIR_ANDROID, DIR_DATA, packageName, DIR_FILES); } public File[] buildExternalStorageAppCacheDirs(String packageName) { return buildPaths(getExternalDirs(), DIR_ANDROID, DIR_DATA, packageName, DIR_CACHE); } } 看到这里我们需要看看StorageManager类: /** * StorageManager is the interface to the systems storage service. The storage * manager handles storage-related items such as Opaque Binary Blobs (OBBs). * &lt;p&gt;(StorageManager是系统存储服务的接口。存储管理器处理与存储相关的项目，如不透明的二进制Blobs(OBBs)。) * * OBBs contain a filesystem that maybe be encrypted on disk and mounted * on-demand from an application. OBBs are a good way of providing large amounts * of binary assets without packaging them into APKs as they may be multiple * gigabytes in size. However, due to their size, they&apos;re most likely stored in * a shared storage pool accessible from all programs. The system does not * guarantee the security of the OBB file itself: if any program modifies the * OBB, there is no guarantee that a read from that OBB will produce the * expected output. * (OBBs包含一个文件系统，可能在磁盘上进行加密，并从应用程序上按需安装。OBBs是提供大量二进制资产的好方法， * 无需将其打包成apk，因为它们的大小可能是多个g。但是，由于它们的大小，它们很可能存储在所有程序中都可以访问的共享存储中。 * 系统不能保证OBB文件本身的安全性:如果有任何程序修改OBB，就不能保证从OBB读取的数据将产生预期的输出。) * */ public class StorageManager { // 其他代码 } 直接上关键代码: /** {@hide} */ public static @NonNull StorageVolume[] getVolumeList(int userId, int flags) { // stub 出来了 final IMountService mountService = IMountService.Stub.asInterface( ServiceManager.getService(&quot;mount&quot;)); try { String packageName = ActivityThread.currentOpPackageName(); if (packageName == null) { // Package name can be null if the activity thread is running but the app // hasn&apos;t bound yet. In this case we fall back to the first package in the // current UID. This works for runtime permissions as permission state is // per UID and permission realted app ops are updated for all UID packages. String[] packageNames = ActivityThread.getPackageManager().getPackagesForUid( android.os.Process.myUid()); if (packageNames == null || packageNames.length &lt;= 0) { return new StorageVolume[0]; } packageName = packageNames[0]; } final int uid = ActivityThread.getPackageManager().getPackageUid(packageName, PackageManager.MATCH_DEBUG_TRIAGED_MISSING, userId); if (uid &lt;= 0) { return new StorageVolume[0]; } return mountService.getVolumeList(uid, packageName, flags); } catch (RemoteException e) { throw e.rethrowFromSystemServer(); } } 我们看到实质获取的是StorageVolume数组; public final class StorageVolume implements Parcelable { private final String mId; private final int mStorageId; private final File mPath; private final String mDescription; private final boolean mPrimary; private final boolean mRemovable; private final boolean mEmulated; private final long mMtpReserveSize; private final boolean mAllowMassStorage; private final long mMaxFileSize; private final UserHandle mOwner; private final String mFsUuid; private final String mState; //其他代码 } 继续查看(IMountService接口中): 下面的就是在这个接口中的源码: public interface IMountService extends IInterface { public StorageVolume[] getVolumeList(int uid, String packageName, int flags) throws RemoteException { Parcel _data = Parcel.obtain(); Parcel _reply = Parcel.obtain(); StorageVolume[] _result; try { _data.writeInterfaceToken(DESCRIPTOR); _data.writeInt(uid); _data.writeString(packageName); _data.writeInt(flags); mRemote.transact(Stub.TRANSACTION_getVolumeList, _data, _reply, 0); _reply.readException(); _result = _reply.createTypedArray(StorageVolume.CREATOR); } finally { _reply.recycle(); _data.recycle(); } return _result; } // 其他代码 } 最后展示常用的Envrionment的获取的路劲: 总结的知识我们一般使用Envrionment来获取设备的存储路劲,但是有些设备返回的是外部设备的地址,例如/storage/emulate/0有的返回的是内置存储的外置.我们直接使用StorageManger来获取所有存储的路劲,我们上面的源码中可以看到,实质就是使用了StorageManger来获取相应的路劲的. 使用StorageManger来获取设备的所有的存储的路劲第一步: 获取StorageManager(通过服务来获取) 第二步,反射获取方法 第三部执行方法. private void getAllStoragerPath() { StorageManager storageManager = (StorageManager) getSystemService(Context.STORAGE_SERVICE); try { Class&lt;?&gt;[] paramClasses = {}; Method getVolumePathsMethod = StorageManager.class.getMethod(&quot;getVolumePaths&quot;, paramClasses); getVolumePathsMethod.setAccessible(true); Object[] params = {}; Object invoke = getVolumePathsMethod.invoke(storageManager, params); for (int i = 0; i &lt; ((String[])invoke).length; i++) { Log.d(TAG, &quot;getAllStoragerPath: &quot;+((String[])invoke)[i]); } } catch (NoSuchMethodException e1) { e1.printStackTrace(); } catch (IllegalArgumentException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } } 还需要注意的Envrionment也提供了Android标准目录的路径: DIRECTORY_ALARMS 系统提醒铃声存放的标准目录。DIRECTORY_DCIM 相机拍摄照片和视频的标准目录。DIRECTORY_DOWNLOADS 下载的标准目录。DIRECTORY_MOVIES 电影存放的标准目录。DIRECTORY_MUSIC 音乐存放的标准目录。DIRECTORY_NOTIFICATIONS 系统通知铃声存放的标准目录。DIRECTORY_PICTURES 图片存放的标准目录DIRECTORY_PODCASTS 系统广播存放的标准目录。DIRECTORY_RINGTONES 系统铃声存放的标准目录。 File externalStoragePublicDirectory = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_MUSIC); // 最后的结果是 storage/emulated/0/Music Log.d(TAG, &quot;svaeData: ceshi&quot;+externalStoragePublicDirectory.toString());]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BottomNavigationView底部导航栏+fragemnt和viewpage的实现实现(二)]]></title>
    <url>%2F2018%2F03%2F01%2FBottomNavigationView%E5%BA%95%E9%83%A8%E5%AF%BC%E8%88%AA%E6%A0%8F%2Bfragemnt%2Bviewpage%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%AE%9E%E7%8E%B0(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[声明: 本文的连接地址(微信打开): http://view.inews.qq.com/w/WXN20180301025918030?refer=nwx&amp;bat_id=1115006214&amp;cur_pos=1&amp;openid=o04IBAOQzAM4aOm6JQYDgPf5unAs&amp;groupid=1519893627&amp;msgid=1 我学习的大牛的微信公众号的文章,特此说明. 记录一点就是自己火狐的通行证 账号: 1024212458@qq.com 密码: 经常使用的哪一个 三月一号,加油学习. 基于上一篇的学习,我们基本对于底部导航栏有一个明确的认识很基本使用,我们常见的是底部导航栏搭配的fragment来使用,完成页面的切换. BottomNavigationView+fragment思路就是我们想集成底部的导航栏,对导航栏进行select的监听; 代码如下: 布局: &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;FrameLayout android:id=&quot;@+id/fl_main_contain&quot; android:layout_above=&quot;@id/bottom_navigation1&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot;&gt; &lt;/FrameLayout&gt; &lt;android.support.design.widget.BottomNavigationView android:id=&quot;@+id/bottom_frgament&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentBottom=&quot;true&quot; app:itemBackground=&quot;@color/colorPrimary&quot; app:itemIconTint=&quot;@drawable/bottom_icon_list&quot; app:itemTextColor=&quot;@drawable/bottom_text_list&quot; app:menu=&quot;@menu/bottom_navigation_main4&quot; /&gt; &lt;/RelativeLayout&gt; menu的代码 如果需要自己寻找图片代替: &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt; &lt;item android:id=&quot;@+id/action_favorites4&quot; android:enabled=&quot;true&quot; android:icon=&quot;@mipmap/canvas&quot; android:title=&quot;@string/text_favorites&quot; app:showAsAction=&quot;ifRoom&quot; /&gt; &lt;item android:id=&quot;@+id/action_launcher4&quot; android:enabled=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:title=&quot;@string/text_schedules&quot; app:showAsAction=&quot;ifRoom&quot; /&gt; &lt;item android:id=&quot;@+id/action_music4&quot; android:enabled=&quot;true&quot; android:icon=&quot;@mipmap/music&quot; android:title=&quot;@string/text_music&quot; app:showAsAction=&quot;ifRoom&quot; /&gt; &lt;item android:id=&quot;@+id/action_sport4&quot; android:enabled=&quot;true&quot; android:icon=&quot;@mipmap/transportation_color_moto&quot; android:title=&quot;@string/text_music&quot; app:showAsAction=&quot;ifRoom&quot; /&gt; &lt;/menu&gt; 我们新建需要的fragment,然后对fragemnt开启事物进行替换.替换的就是对我们展示的FrameLayout的布局. 具体的代码如下: /** * 事物的处理 */ private void initEvent() { bottom_frgament.setOnNavigationItemSelectedListener(new BottomNavigationView.OnNavigationItemSelectedListener() { @Override public boolean onNavigationItemSelected(@NonNull MenuItem item) { switch (item.getItemId()) { case R.id.action_favorites4: // 点击的时候切换的 就是我们的FrameLayout getSupportFragmentManager().beginTransaction().replace(R.id.fl_main_contain, own1Fragment).commit(); return true; // break; case R.id.action_launcher4: getSupportFragmentManager().beginTransaction().replace(R.id.fl_main_contain, own1Fragment).commit(); return true; // break; case R.id.action_music4: getSupportFragmentManager().beginTransaction().replace(R.id.fl_main_contain, own1Fragment).commit(); return true; // break; case R.id.action_sport4: getSupportFragmentManager().beginTransaction().replace(R.id.fl_main_contain, own1Fragment).commit(); return true; // break; } return false; } }); } 注意的是关于supportfragment和fragment,然后就是监听select的时候返回使用return true,不然不会生效.还有就是事物提交时候注意的事项. BottomNavigationView+viewpage这次要实现的是关于BottomNavigation和Viewpage实现,我们发现底部导航只能点击进入下一个页面,不能滑动到下一个页面,我们搭建viewpage的组合; 页面的布局展示: 初始化结束后先给ViewPage设置设置适配器 关于viewpage的适配器的选择关于适配器的学习连接: http://blog.csdn.net/jack_king007/article/details/41413405 第一点就是 PagerAdapter 是基类, FragmentPagerAdapter 是继承PagerAdapter 的,FragmentStatePagerAdapter也是继承于PagerAdapter. 我们直接使用FrgamentAdapter: 代码如下: public class VgAdapter extends FragmentPagerAdapter{ private List&lt;Fragment&gt; fragmentList ; public VgAdapter(FragmentManager fm, List&lt;Fragment&gt; fragments) { super(fm); fragmentList=fragments; } @Override public Fragment getItem(int position) { Fragment fragment = fragmentList.get(position); return fragment; } @Override public int getCount() { return fragmentList.size(); } } 在主页面设置adapter和对BottomNavigationView监听,展示返回true,不然底部不能点金,此时发现底部可以点金,viewpage也可以滑动,下面就是关联起来. 这是昨天的一些遗漏,我们今天主要是对ViewPage的适配器的学习,上面介绍了关于Viewpage的三种适配器,我们分别继承来实现我们当前的viewpage的实现. 第一个就是继承FagmentPagerAdapter类具体代码的实现在上面,这里面说说,类中方法的实现含义,构造方法便于传递一个FragmentManager,后面的list是便于Fragment的传递,geItem(postion),根据postion绑定对应的fragment. 最后是getCount(),返回的是页面的size. 实现起来比较方便. 第二个adapter继承基类PagerAdapter使用pageradapter，至少必须重写下面的四个方法【 instantiateItem(ViewGroup, int)】 这个函数的实现的功能是创建指定位置的页面视图。适配器有责任增加即将创建的View视图到这里给定的container中，这是为了确保在finishUpdate(viewGroup)返回时这个已经完成返回值：返回一个代表新增视图页面的Object 【public void destroyItem (ViewGroup container, int position, Object object)】 该方法实现的功能是移除一个给定位置的页面。适配器有责任从容器中删除这个视图。这是为了确保在finishUpdate(viewGroup)返回时视图能够被移除。【 public int getCount()】 返回当前有效视图的个数。 【isViewFromObject(View, Object)】 功能：该函数用来判断instantiateItem(ViewGroup, int)函数所返回来的Key与一个页面视图是否是代表的同一个视图(即它俩是否是对应的，对应的表示同一个View)返回值：如果对应的是同一个View，返回True，否则返回False。 代码展示: public class ViewPagerPageAdapter extends PagerAdapter { private List fragmentList; private List mVIEWList; /*public ViewPagerPageAdapter(List&lt;Fragment&gt; fragments) { fragmentList = fragments; }*/ public ViewPagerPageAdapter(Context context) { TextView textView = new TextView(context); textView.setText(&quot;这是textview&quot;); mVIEWList = new ArrayList&lt;&gt;(); mVIEWList.add(textView); mVIEWList.add(textView); mVIEWList.add(textView); mVIEWList.add(textView); } @Override public Object instantiateItem(ViewGroup container, int position) { container.addView( mVIEWList.get(position)); return mVIEWList.get(position); } @Override public void destroyItem(ViewGroup container, int position, Object object) { container.removeView( mVIEWList.get(position)); } @Override public int getCount() { return mVIEWList.size(); } @Override public boolean isViewFromObject(View view, Object object) { return view==object; } } 还有一个FragmentStatePagerAdapter代码展示如下: public class VPFragmentStusAdapter extends FragmentStatePagerAdapter { private List&lt;Fragment&gt; fragmentList; public VPFragmentStusAdapter(FragmentManager fm, List&lt;Fragment&gt; fragments) { super(fm); fragmentList = fragments; } @Override public Fragment getItem(int position) { return fragmentList.get(position); } @Override public int getCount() { return fragmentList.size(); } } 在Activity中的使用的情况也是一致的. 这个类也是继承与PagerAdapter; 使用于多个tab页面的情况. 最后是适配器的区别首先他们都是继承自PagerAdapter，FragmentPagerAdapter适合使用在固定的数量较少的场景，比如本例的4个tab的fragment滑动界面，而FragmentStatePagerAdapter适合适合用在多个tab场景下，并且会保存当前界面以及下一个界面和上一界面，最多可以保留3个（具体源码分析参见http://blog.csdn.net/jackrex/article/details/9885469?utm_source=tuicool&amp;utm_medium=referral）他们的使用方式一致 底部点击和viewpage绑定的fragment的切话首先是底部选中切换到对应的viewpage: 代码如下: 图中有注意点,我们case后面使用break,也可以实现点击底部导航栏完成viewpage的切换,但是使用break的话,底部不会出现选择和为选择时候颜色的变化. // 设置viewpage的滑动的监听 mVg_bvg.addOnPageChangeListener(this); 上面我们已经实现了对底部点击和viewpage中对应fragment的切话,你仔细看还有一个问题那就是我们滑动的时候,底部不会变化. 滑动viewpage出现对底部同步变化哪我们想到是什么时候viewpage滑动,我们需要监听viewpage在做出底部的切换. 我们知道底部导航栏使用的menu指定的元素,BottomNavigationView的源码方法可以获取一个menu; 我们进Menu源码查看 我们可以finIteam(postion),滑动到哪里我们可以获取到postion的iteam,之个对象是MenuIteam,我们进去看看: 最后成功关联. 最后的代码展示: 最后的展示图片(ps图片这张是借用的):]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BottomNavigationView实现底部导航栏的实现(一)]]></title>
    <url>%2F2018%2F02%2F08%2FBottomNavigationView%E5%AE%9E%E7%8E%B0%E5%BA%95%E9%83%A8%E5%AF%BC%E8%88%AA%E6%A0%8F%E7%9A%84%E5%AE%9E%E7%8E%B0(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[支持库的依赖(Android Design Support Library)开始之前打一波推广,推广的就是我自己,最近喜欢hexo的博客主题,自己上手搭建一个,从开始使用到Hexo的个性化配置,自己边学习边记录,形成了Hexo搭建个人网站的一个体系,同步在个人的博客上: http://kunkun5love.club 本文是对底部导航学习和最后笔记记录,使用的是BottomNavigationView 控件. 选取常见的图标: 注意: 下面的连接请在微信上打开 学习的笔记来源是微信公众号的文章: 连接如下http://mp.weixin.qq.com/s/k6GUzoE5b-MiekmrO9_VTg 支持库的依赖首先是上代码: // 支持库 compile &apos;com.android.support:design:25.3.1&apos; 不然是不会出现对应的提示; 开始新建布局书写开始之前学习一下子 ColorStateList 类型的资源: https://www.cnblogs.com/xirihanlin/archive/2010/06/11/1756121.html ColorStateList对象可以在XML中定义，像color一样使用，它能根据它应用到的View对象的状态实时改变颜色。例如，Button可以存在多种状态（pressed、focused或other），如果使用ColorStateList，你就能为它的每个状态提供不同的颜色。 新建项目开始决定来书写: 添加布局文件时候注意的事项: 属性一: iteamBackground 指定的是底部导航栏的背景颜色,默认是主题的颜色; 属性二: iteamIconTint 指的是导航栏中图片的颜色 属性三: iteamTextColor 指的是导航栏文字的颜色 属性四: menu BottomNavigationView在使用时，除了普通空间的属性外，还需要注意如下几个特有属性： app:itemBackground:指定底部导航栏的背景颜色，默认是当前主题的背景色，白色or黑色； app:itemIconTint:指定底部导航栏元素图标的着色方式，默认元素选中时icon颜色为@color/colorPrimary；app:itemTextColor:指定底部导航栏元素文字的着色方式； app:menu:使用Menu的形式为底部导航栏指定元素； 首先是代码的展示: &lt;android.support.design.widget.BottomNavigationView android:id=&quot;@+id/bottom_navigation&quot; android:layout_alignParentBottom=&quot;true&quot; app:itemBackground=&quot;@color/colorAccent&quot; app:itemIconTint=&quot;@color/status_text&quot; app:itemTextColor=&quot;@color/yellow&quot; app:menu=&quot;@menu/bottom_navigation_main&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; /&gt; 之后是使用men给底部导航指定对应的元素: &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt; &lt;item android:id=&quot;@+id/action_favorites&quot; android:enabled=&quot;true&quot; android:icon=&quot;@mipmap/canvas&quot; android:title=&quot;@string/text_favorites&quot; app:showAsAction=&quot;ifRoom&quot; /&gt; &lt;item android:id=&quot;@+id/action_schedules&quot; android:enabled=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:title=&quot;@string/text_schedules&quot; app:showAsAction=&quot;ifRoom&quot; /&gt; &lt;item android:id=&quot;@+id/action_music&quot; android:enabled=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:title=&quot;@string/text_music&quot; app:showAsAction=&quot;ifRoom&quot; /&gt; &lt;/menu&gt; 展示的效果图: 实现选中和未选中的颜色变化我们看到的底部导航栏的实现中,选中和未选中的颜色是不一致的,我们看到 itemIconTint属性和itemTextColor都是前面提到过的ColorStatusList对象,也就是我们可以设置对应的选择和未选中时候的颜色list. 新建bottom_item_icon_tint_list.xml文件,设置的是图标选择和未选中的颜色的着色的方式. 记录新建一个drawable的xml小操作时间长了,这个都忘记了,首先是一个具有状态对应的像color使用一样的drawable. 在drawable选中,右击→new →Drawable Resources file 展示如下: 输入文件的名称后(后面不需要.xml,只需要的是文件的名称),创建成功展示如下: 代码展示和说明: &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:state_checked=&quot;true&quot; android:color=&quot;@color/background_blue&quot; &gt;&lt;/item&gt; &lt;item android:state_checked=&quot;false&quot; android:color=&quot;@color/yellow&quot;&gt;&lt;/item&gt; &lt;/selector&gt; 一个状态对应于一个iteam,我们这里设置的图片的着色是选择blue,未选中黄色,我们依次设置文字的颜色一致. 感慨一下子,书写代码要注意力很集中,不集中出现的错误需要我们花费更大的精力去执行检查错误. 选中和未选中图片的变化的设置上面的设置是在选中和未选中的时候着色的设置,如果是图片的话怎么做. 选中使用的是一个颜色,那我们也可以在选中的时候使用一张图片,没有选中的时候使用一张图片. 那么就是一个选择器,我们直接创建. bottom_png_list.xml; &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:state_checked=&quot;true&quot; android:drawable=&quot;@drawable/music&quot;&gt;&lt;/item&gt; &lt;item android:drawable=&quot;@drawable/music_gray&quot;&gt;&lt;/item&gt; &lt;/selector&gt; 图片展示如下: 我们使用的meu菜单设置元素到底部导航栏里面的,引用图片的位置换一下就行了! &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt; &lt;item android:id=&quot;@+id/action_favorites&quot; android:enabled=&quot;true&quot; android:icon=&quot;@drawable/bottom_png_list&quot; android:title=&quot;@string/text_favorites&quot; app:showAsAction=&quot;ifRoom&quot; /&gt; &lt;item android:id=&quot;@+id/action_schedules&quot; android:enabled=&quot;true&quot; android:icon=&quot;@drawable/bottom_png_list&quot; android:title=&quot;@string/text_schedules&quot; app:showAsAction=&quot;ifRoom&quot; /&gt; &lt;item android:id=&quot;@+id/action_music&quot; android:enabled=&quot;true&quot; android:icon=&quot;@drawable/bottom_png_list&quot; android:title=&quot;@string/text_music&quot; app:showAsAction=&quot;ifRoom&quot; /&gt; &lt;/menu&gt; 此时不需要设置 itemIconTint和itemTextColor 颜色 也可以在代码中设置 iconTint为null: mBottomNavigationView2.setItemIconTintList(null); 运行展示: 下面的就是对菜单menu的监听和页面的切换. 四个导航栏的问题测试的模拟器的分辨率是 720*480 p Java 中Math.min(a,b)是比较a和b 的大小,返回的是较小的数值. 设置和前面的一样,我们不在展示,展示的是出现的问题. 我们直接进BottomNavigationView的源码查看: BottomNavigationView源码 说明最大值item有一个值:(这个值是5) 我们设置五个iteam看看,没有出错,展示的图片如下: 最大支持的是5个iteam,我们加到六个iteam,看看结果是怎么样的: 结果是直接出错了,我们直接看看错误的信息是展示: 这里面明确的说明BottomNavigationView支持的最大的number of iteam 是5 2018/2/28 13:57:02 我们继续下面的这个问题,为什么没有平分布局,展示源码如下: 出现了一个新类,在后面设置了setBottomNavigationMenuView 进入到BottomNavigationMeunView我们直接看 onMeasure()方法. // 源码 - BottomNavigationMeunView.class @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { final int width = MeasureSpec.getSize(widthMeasureSpec); final int count = getChildCount(); final int heightSpec = MeasureSpec.makeMeasureSpec(mItemHeight, MeasureSpec.EXACTLY); if (mShiftingMode) { final int inactiveCount = count - 1; final int activeMaxAvailable = width - inactiveCount * mInactiveItemMinWidth; final int activeWidth = Math.min(activeMaxAvailable, mActiveItemMaxWidth); final int inactiveMaxAvailable = (width - activeWidth) / inactiveCount; final int inactiveWidth = Math.min(inactiveMaxAvailable, mInactiveItemMaxWidth); int extra = width - activeWidth - inactiveWidth * inactiveCount; for (int i = 0; i &lt; count; i++) { mTempChildWidths[i] = (i == mSelectedItemPosition) ? activeWidth : inactiveWidth; if (extra &gt; 0) { mTempChildWidths[i]++; extra--; } } } else { final int maxAvailable = width / (count == 0 ? 1 : count); final int childWidth = Math.min(maxAvailable, mActiveItemMaxWidth); int extra = width - childWidth * count; for (int i = 0; i &lt; count; i++) { mTempChildWidths[i] = childWidth; if (extra &gt; 0) { mTempChildWidths[i]++; extra--; } } } int totalWidth = 0; for (int i = 0; i &lt; count; i++) { final View child = getChildAt(i); if (child.getVisibility() == GONE) { continue; } child.measure(MeasureSpec.makeMeasureSpec(mTempChildWidths[i], MeasureSpec.EXACTLY), heightSpec); ViewGroup.LayoutParams params = child.getLayoutParams(); params.width = child.getMeasuredWidth(); totalWidth += child.getMeasuredWidth(); } setMeasuredDimension( ViewCompat.resolveSizeAndState(totalWidth, MeasureSpec.makeMeasureSpec(totalWidth, MeasureSpec.EXACTLY), 0), ViewCompat.resolveSizeAndState(mItemHeight, heightSpec, 0)); } 快速执行: shift + F10 连接上的会直接回车 执行停止的命令: ctrl+ F2 debug运行的命令: shift + F9 连接的话是直接回车就行. 我debug一些信息: 学习一个英文单词: inactive 闲置的; 闲置的iteam最大宽度是:144 闲置的iteam最小的宽度是: 84 激活的iteam的最大的宽度是252 iteam的高度是: 84 我们看到一个判断 mShitingMode,我们看看这个变量 后面有没有对这个变量的再次赋值: 我们这里看到menu.size有一个判断, 判断值是3 大于三是true,不大于是false 当mShitingMode=false的时候此时表示的iteam的数量在三或者之下: dubug的展示图片: 我们看到此时所有的childWidth的宽度是240 这个宽度= 获取的width/count (此时debug的count是3) 当mShifingMode = true的时候对onMeasure进行debug测试: 此时的模拟器 720*480 count 数量是5 看出选中的宽度是 252 限制的宽度是117 问题的处理全局搜索: double shift; 当我们iteam是大于5的时候,我们获取到 mShifingMode,设置为false,就会平分了! 还有注意的一点,忘记说了: 反射获取: 连接你地址:https://stackoverflow.com/questions/40176244/how-to-disable-bottomnavigationview-shift-mode 复制网上的代码: /** * Created by Administrator on 2018/2/28. */ public class BottomNavigationViewHelper { @SuppressLint(&quot;RestrictedApi&quot;) public static void disableShiftMode(BottomNavigationView view) { BottomNavigationMenuView menuView = (BottomNavigationMenuView) view.getChildAt(0); try { Field shiftingMode = menuView.getClass().getDeclaredField(&quot;mShiftingMode&quot;); shiftingMode.setAccessible(true); shiftingMode.setBoolean(menuView, false); shiftingMode.setAccessible(false); for (int i = 0; i &lt; menuView.getChildCount(); i++) { BottomNavigationItemView item = (BottomNavigationItemView) menuView.getChildAt(i); //noinspection RestrictedApi item.setShiftingMode(false); // set once again checked value, so view will be updated //noinspection RestrictedApi item.setChecked(item.getItemData().isChecked()); } } catch (NoSuchFieldException e) { Log.e(&quot;BNVHelper&quot;, &quot;Unable to get shift mode field&quot;, e); } catch (IllegalAccessException e) { Log.e(&quot;BNVHelper&quot;, &quot;Unable to change value of shift mode&quot;, e); } } } 在Activity中的使用: 运行看看: 其他的设置对底部导航设置如下: 第一设置图片和文字之间的距离直接在dimens中设置: &lt;dimen tools:override=&quot;true&quot; name=&quot;design_bottom_navigation_margin&quot;&gt;5dp&lt;/dimen&gt; 展示效果如下: 增加底部导航栏的高度默认的底部导航栏的高度是 56dp &lt;dimen tools:override=&quot;true&quot; name=&quot;design_bottom_navigation_height&quot;&gt;84dp&lt;/dimen&gt; 展示如下: 设置选中后字体不变我们现在设置的选中的时候字体会变大,我们设置为不变: &lt;dimen tools:override=&quot;true&quot; name=&quot;design_bottom_navigation_text_size&quot;&gt;12sp&lt;/dimen&gt; &lt;dimen tools:override=&quot;true&quot; name=&quot;design_bottom_navigation_active_text_size&quot;&gt;12sp&lt;/dimen&gt; 设置选中和未选中的字体的大小一致解决: 不展示了! 最后放一下子我学习的微信公众号 最后是自己的个人网站: kunkun5love.club 自己博客地址: kunkun5love.tk]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>底部导航</tag>
        <tag>支持库</tag>
        <tag>BottomNavigationView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[升级apk和更新安装apk的整理]]></title>
    <url>%2F2018%2F01%2F31%2F%E5%8D%87%E7%BA%A7apk%E5%92%8C%E6%9B%B4%E6%96%B0%E5%AE%89%E8%A3%85apk%E7%9A%84%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[本片是对于安装更新apk的一个集成功能的总结和流程和总结,便于后期遇到,直接复制粘贴使用,需要的文件全部都有,按照自己的思路来总结的,比较详细,也比较多余,权当做是一个笔记来对待就行. #延迟展示对话框 # private void initView() { .... //r:消息的执行操作 //delayMillis : 延迟时间,但是毫秒值 new Handler().postDelayed(new Runnable() { @Override public void run() { //提醒用户更新版本 update(); } }, 2000);//延迟多少时间给handler发送消息 //delayMillis : 延迟时间,单位毫秒值 /*new Handler(){ public void handleMessage(android.os.Message msg) { //提醒用户更新版本 update(); }; }.sendEmptyMessageDelayed(0, 2000);*///延迟多长时间给handler发送消息 } 自己学习和总结的关于app的升级和安装就是我们在splash页面(自己随意)先获取自己的版本VersionCode我们在获取服务端的一个json,获取里面的serverVersionCode,比较这两个值,ServerVersionCode &gt; versionCode 进行弹出对话框提示跟新,否则继续执行动画.点击下次在说继续执行动画,点击现在下载,进行下载,之后下载安转. 下载使用的是系统的DownloadManager,下载完成后发送广播,我们需要先注册一个广播 关于VersionCode和VersionName的区别首先就引用一下子: Google为APK定义了两个关于版本属性：VersionCode和VersionName，他们有不同的用途。 VersionCode：对消费者不可见，仅用于应用市场、程序内部识别版本，判断新旧等用途。 VersionName：展示给消费者，消费者会通过它认知自己安装的版本 ok自己总结一下: 第一点就是: versioncode是用于版本更新和应用市场来判断是否提醒用户进行安装的一个标识. 而versionName是我们在安转软件的时候展示给用户观看的自己的安装的版本. 第二点是: verSionCode比较正式,而VersionName就比较随意了,可以随意的取名称. 获取app的versionCode和versionName直接上源码: public class PackageUtils { public static String getVersionName(Context mContext){ // 获取package管理者 需要上下文 PackageManager packageManager = mContext.getPackageManager(); //参数说明 参数一是获取哪一个包名的package的信息 (application包括了activity所以也会包括activity的信息) //参数二的信息就是设置是不是之后去 //获取包名的方法 String packageName = mContext.getPackageName(); try { PackageInfo packageInfo = packageManager.getPackageInfo(packageName, 0); //获取里面的信息 String versionName = packageInfo.versionName; return versionName; } catch (PackageManager.NameNotFoundException e) { e.printStackTrace(); } // 获取里面的信息 // applicationInfo. return null; } // 获取版本信息 public static int getVersionCode(Context mContext){ // 获取package管理者 需要上下文 PackageManager packageManager = mContext.getPackageManager(); //参数说明 参数一是获取哪一个包名的package的信息 (application包括了activity所以也会包括activity的信息) //参数二的信息就是设置是不是获取其他的权限还是获取广播,设置为0只是获取简单的版本名称和版本信息 //获取包名的方法 String packageName = mContext.getPackageName(); try { PackageInfo packageInfo = packageManager.getPackageInfo(packageName, 0); //获取里面的信息 int versionCode = packageInfo.versionCode; return versionCode; } catch (PackageManager.NameNotFoundException e) { e.printStackTrace(); } return -1; } } 服务端的获取的信息我访问服务端去获取服务端上app的VersionCode: 获取的json的展示: { &quot;data&quot;: { &quot;ServerVersionCode&quot;: &quot;2&quot;, &quot;ServerVersionName&quot;: &quot;1.0.2&quot;, &quot;appname&quot;: &quot;fabei.apk&quot;, &quot;updateurl&quot;: &quot;http://IP地址/apk/fabei.apk&quot;, &quot;upgradeinfo&quot;: &quot;V1.0.2版本更新，你想不想要试一下哈！！！&quot; }, &quot;code&quot;: &quot;200&quot;, &quot;code_msg&quot;: &quot;获取成功&quot; } 我们可以看到下载地址. 关于Retrofit的集成注意gradle中的添加的依赖: //网络请求框架 compile &apos;com.squareup.retrofit2:retrofit:2.3.0&apos; compile &apos;com.squareup.retrofit2:converter-scalars:2.3.0&apos; compile &apos;com.squareup.retrofit2:converter-gson:2.3.0&apos; compile &apos;com.squareup.retrofit2:adapter-rxjava2:2.3.0&apos; //RxJava框架 compile &apos;io.reactivex.rxjava2:rxandroid:2.0.1&apos; compile &apos;io.reactivex.rxjava2:rxjava:2.1.5&apos; //运行时权限 compile &apos;com.tbruyelle.rxpermissions2:rxpermissions:0.9.1@aar&apos; // 后面说到这个库 使用一个管理类: public class RetrofitManager { private static RetrofitManager mRetrofitManager; private static Retrofit mRetrofit; private static Retrofit mDRetrofit; private RetrofitManager() { } /** * 创建网络请求 * * @param reqServer 网络接口 * @param &lt;T&gt; 泛型 * @return 返回网络接口对应的请求类 */ private &lt;T&gt; T createReq(Class&lt;T&gt; reqServer) { return mRetrofit.create(reqServer); } /** * 获取服务器网络请求接口对应的类 * * @return 服务器网络请求接口对应的类 */ public ServerApi getServer() { return createReq(ServerApi.class); } /** * 返回线程安全的单例 * * @return RetrofitManager单例 */ public static synchronized RetrofitManager getInstance() { if (mRetrofitManager == null) { mRetrofitManager = new RetrofitManager(); } return mRetrofitManager; } //在自定义Application中初始化 public static void init() { OkHttpClient.Builder builder = new OkHttpClient.Builder(); builder.connectTimeout(50, TimeUnit.SECONDS); builder.readTimeout(50, TimeUnit.SECONDS); builder.writeTimeout(50, TimeUnit.SECONDS); builder.retryOnConnectionFailure(true); OkHttpClient client = builder.build(); mRetrofit = new Retrofit.Builder() .baseUrl(UrlConstant.BASE_URL) .addConverterFactory(ScalarsConverterFactory.create()) .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) //通过RxJavaCallAdapterFactory为Retrofit添加RxJava支持： .client(client) .build(); } } 贴一个ServerApi.class 的接口类: public interface ServerApi { //其他的代码 /** * 获取跟新app服务器信息 * @return */ @GET(&quot;apk/upgrade.json&quot;) // 这里面就是去掉主机host的其他路劲 Observable&lt;UpdateAppInfo&gt; getUpdateVersion (); } 贴一个接口类: UrlConstant: public interface UrlConstant { //服务器地址 public static final String BASE_URL = &quot;主机ip地址&quot;; //本机地址 //public static final String BASE_URL = &quot;http://192.168.0.121:8080&quot;; } splash界面代码书写splash的初始化界面: 便于接收到下载完成的通知,我们先初始化广播;在检查更新 initUpdata(); // 是否具有新版本 checkUpdate(); 具体的方法代码: /** * 初始化app更新广播 */ private void initUpdata() { IntentFilter filter = new IntentFilter(); filter.addAction(DownloadManager.ACTION_DOWNLOAD_COMPLETE); filter.addAction(DownloadManager.ACTION_NOTIFICATION_CLICKED); filter.addCategory(&quot;android.intent.category.DEFAULT&quot;); receiver = new DownLoadCompleteReceiver(); registerReceiver(receiver, filter); } 实质就是动态注册广播,action如下: filter.addAction(DownloadManager.ACTION_DOWNLOAD_COMPLETE); // 接收下载完成后的广播通知 filter.addAction(DownloadManager.ACTION_NOTIFICATION_CLICKED); 上面的都是为了安装更新做准备. 我们看看检查更新: chenckUpdate(); private void checkUpdate() { RetrofitManager.getInstance() .getServer() .getUpdateVersion() .compose(RxUtils.&lt;UpdateAppInfo&gt;apply()) .subscribe(new Observer&lt;UpdateAppInfo&gt;() { @Override public void onSubscribe(Disposable d) { Log.d(TAG, &quot;onSubscribe: &quot; + d.toString()); } @Override public void onNext(UpdateAppInfo updateAppInfo) { if (TextUtils.equals(&quot;200&quot;, updateAppInfo.getCode())) { String appname = updateAppInfo.getData().getAppname(); String serverVersionCode = updateAppInfo.getData().getServerVersionCode(); String serverVersionName = updateAppInfo.getData().getServerVersionName(); String updateurl = updateAppInfo.getData().getUpdateurl(); String updateinfo = updateAppInfo.getData().getUpgradeinfo(); String code_msg = updateAppInfo.getCode_msg(); Long aLong = Long.parseLong(serverVersionCode); SpUtils.getInstance().putString(UserConstant.UPDATE_URL, updateurl); if (aLong &gt; PackageUtils.getVersionCode(mContext)) { showUpdateConfirmDialog(mContext, updateinfo); }else{ // 没有更新 mHandler.sendEmptyMessage(0x10102); } } } @Override public void onError(Throwable e) { Log.d(TAG, &quot;onError: 错误信息&quot; + e); } @Override public void onComplete() { } }); } Handler也来一段,直接复制: private Handler mHandler = new Handler() { @Override public void handleMessage(Message msg) { if (msg.what==0x10102){ // ToastUtils.showShort(mContext,&quot;执行splash&quot;); continueSplash(); // 继续执行splash的动画 } } }; 关于continueSplash();方法 private void continueSplash() { //计时器定义 final CountDownTimer countDownTimer = new CountDownTimer(3000, 1000) { @Override public void onTick(long millisUntilFinished) { } @Override public void onFinish() { //启动之后，判断是不是第一次启动 if (SpUtils.getInstance().getBoolean(SPConstant.IS_FIRST_ENTRY, true)) { //前往欢迎界面 Intent intent = new Intent(mContext, WelcomeActivity.class); AnimationUtils.startActivity(mContext, intent); SpUtils.getInstance().putBoolean(SPConstant.IS_FIRST_ENTRY, false); finish(); } else { //前往登录界面 Intent intent = new Intent(mContext, LoginActivity.class); AnimationUtils.startActivity(mContext, intent); finish(); } } }; // 如果大于23 使用RxPermissions库来 if (Build.VERSION.SDK_INT &gt; 23) { //请求权限 RxPermissions rxPermissions = new RxPermissions(SplashActivity.this); String[] permissions = {Manifest.permission.WRITE_EXTERNAL_STORAGE}; rxPermissions.request(permissions) .subscribe(new Observer&lt;Boolean&gt;() { @Override public void onSubscribe(Disposable d) { } @Override public void onNext(Boolean aBoolean) { } @Override public void onError(Throwable e) { countDownTimer.start(); } @Override public void onComplete() { countDownTimer.start(); } }); } else { countDownTimer.start(); } } 缺少文件补充一: SpUtils.class public class SpUtils { private static Context mContext; private static SharedPreferences sp; private static SharedPreferences.Editor editor; private static SpUtils instance; public static void init(Context context) { mContext = context; if (mContext != null) { sp = mContext.getSharedPreferences(SPConstant.SP_NAME, Context.MODE_PRIVATE); editor = sp.edit(); boolean commit = editor.commit(); } else { throw new IllegalStateException(&quot;init the SharedPreferences first please!&quot;); } } /** * SPUtils构造函数 */ private SpUtils() { } public static SpUtils getInstance() { if (mContext != null) { if (instance == null) { instance = new SpUtils(); } } else { throw new IllegalStateException(&quot;init the SharedPreferences first please!&quot;); } return instance; } /** * SP中写入String类型value * * @param key 键 * @param value 值 */ public void putString(String key, String value) { editor.putString(key, value).commit(); } /** * SP中读取String * * @param key 键 * @return 存在返回对应值，不存在返回默认值{@code null} */ public String getString(String key) { return getString(key, null); } /** * SP中读取String * * @param key 键 * @param defaultValue 默认值 * @return 存在返回对应值，不存在返回默认值{@code defaultValue} */ public String getString(String key, String defaultValue) { return sp.getString(key, defaultValue); } /** * SP中写入int类型value * * @param key 键 * @param value 值 */ public void putInt(String key, int value) { editor.putInt(key, value).commit(); } /** * SP中读取int * * @param key 键 * @return 存在返回对应值，不存在返回默认值-1 */ public int getInt(String key) { return getInt(key, -1); } /** * SP中读取int * * @param key 键 * @param defaultValue 默认值 * @return 存在返回对应值，不存在返回默认值{@code defaultValue} */ public int getInt(String key, int defaultValue) { return sp.getInt(key, defaultValue); } /** * SP中写入long类型value * * @param key 键 * @param value 值 */ public void putLong(String key, long value) { editor.putLong(key, value).commit(); } /** * SP中读取long * * @param key 键 * @return 存在返回对应值，不存在返回默认值-1 */ public long getLong(String key) { return getLong(key, -1L); } /** * SP中读取long * * @param key 键 * @param defaultValue 默认值 * @return 存在返回对应值，不存在返回默认值{@code defaultValue} */ public long getLong(String key, long defaultValue) { return sp.getLong(key, defaultValue); } /** * SP中写入float类型value * * @param key 键 * @param value 值 */ public void putFloat(String key, float value) { editor.putFloat(key, value).commit(); } /** * SP中读取float * * @param key 键 * @return 存在返回对应值，不存在返回默认值-1 */ public float getFloat(String key) { return getFloat(key, -1f); } /** * SP中读取float * * @param key 键 * @param defaultValue 默认值 * @return 存在返回对应值，不存在返回默认值{@code defaultValue} */ public float getFloat(String key, float defaultValue) { return sp.getFloat(key, defaultValue); } /** * SP中写入boolean类型value * * @param key 键 * @param value 值 */ public void putBoolean(String key, boolean value) { editor.putBoolean(key, value).commit(); } /** * SP中读取boolean * * @param key 键 * @return 存在返回对应值，不存在返回默认值{@code false} */ public boolean getBoolean(String key) { return getBoolean(key, false); } /** * SP中读取boolean * * @param key 键 * @param defaultValue 默认值 * @return 存在返回对应值，不存在返回默认值{@code defaultValue} */ public boolean getBoolean(String key, boolean defaultValue) { return sp.getBoolean(key, defaultValue); } /** * 获取SP中所有键值对 * * @return Map对象 */ public Map&lt;String, ?&gt; getAll() { return sp.getAll(); } /** * 从SP中移除该key * * @param key 键 */ public void remove(String key) { editor.remove(key).commit(); } /** * 判断SP中是否存在该key * * @param key 键 * @return {@code true}: 存在&lt;br&gt;{@code false}: 不存在 */ public boolean contains(String key) { return sp.contains(key); } /** * 清除SP中所有数据 */ public void clear() { editor.clear().commit(); } } 缺少文件补充二: AnimationUtils.class: public class AnimationUtils { public static void backActivity(Context context) { ((Activity) context).overridePendingTransition(R.anim.open_last, R.anim.close_next); } public static void startActivity(Context context, Intent intent) { context.startActivity(intent); ((Activity) context).overridePendingTransition(R.anim.open_next, R.anim.close_last); } public static void startActivityForResult(Context context, Intent intent, int code) { ((Activity) context).startActivityForResult(intent, code); ((Activity) context).overridePendingTransition(R.anim.open_next, R.anim.close_last); } public static void startAlphaActivity(Context context, Intent intent) { context.startActivity(intent); ((Activity) context).overridePendingTransition(R.anim.alpha_open, R.anim.alpha_colse); } public static void startAlphaActivityForResult(Context context, Intent intent, int code) { ((Activity) context).startActivityForResult(intent, code); ((Activity) context).overridePendingTransition(R.anim.alpha_open, R.anim.alpha_colse); } } 缺少的动画文件: res新建文件夹anim 第一个: opne_last.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt; &lt;translate android:interpolator=&quot;@android:anim/accelerate_interpolator&quot; android:duration=&quot;400&quot; android:fromYDelta=&quot;0&quot; android:toYDelta=&quot;0&quot; android:fromXDelta=&quot;-20%p&quot; android:toXDelta=&quot;0&quot;/&gt; &lt;/set&gt; 第二个: open_next.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt; &lt;translate android:duration=&quot;400&quot; android:fromXDelta=&quot;100%p&quot; android:fromYDelta=&quot;0&quot; android:interpolator=&quot;@android:anim/accelerate_interpolator&quot; android:toXDelta=&quot;0&quot; android:toYDelta=&quot;0&quot;/&gt; &lt;/set&gt; 第三个: close_next.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt; &lt;translate android:duration=&quot;400&quot; android:fromXDelta=&quot;0&quot; android:fromYDelta=&quot;0&quot; android:interpolator=&quot;@android:anim/accelerate_interpolator&quot; android:toXDelta=&quot;100%p&quot; android:toYDelta=&quot;0&quot; /&gt; &lt;/set&gt; 第四个: close_last.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt; &lt;translate android:interpolator=&quot;@android:anim/accelerate_interpolator&quot; android:duration=&quot;800&quot; android:fromXDelta=&quot;0&quot; android:toXDelta=&quot;-20%p&quot; android:fromYDelta=&quot;0&quot; android:toYDelta=&quot;0&quot;/&gt; &lt;/set&gt; 第五个: alpha_close.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;alpha android:duration=&quot;400&quot; android:fromAlpha=&quot;1.0&quot; android:interpolator=&quot;@android:anim/linear_interpolator&quot; android:toAlpha=&quot;0.0&quot; /&gt; &lt;/set&gt; 第六个: alpha_ipen.xml: &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt; &lt;alpha android:duration=&quot;400&quot; android:fromAlpha=&quot;0.0&quot; android:interpolator=&quot;@android:anim/linear_interpolator&quot; android:toAlpha=&quot;1.0&quot; /&gt; &lt;/set&gt; 缺少文件SPConstant public interface SPConstant { public static final String SP_NAME = &quot;spName&quot;; public static final String IS_FIRST_ENTRY = &quot;isFirstEntry&quot;; } 6.0权限的申请具体的细节说明和简单的使用: 具体的细节看我博客: http://blog.csdn.net/kunkun5love/article/details/73311761 github上面的RxPermission的: https://github.com/tbruyelle/RxPermissions // 首先是gradle的依赖 dependencies { compile &apos;com.tbruyelle.rxpermissions2:rxpermissions:0.9.5@aar&apos; } 代码中的使用: if (Build.VERSION.SDK_INT &gt; 23) { //请求权限 RxPermissions rxPermissions = new RxPermissions(SplashActivity.this); String[] permissions = {Manifest.permission.WRITE_EXTERNAL_STORAGE}; rxPermissions.request(permissions) .subscribe(new Observer&lt;Boolean&gt;() { @Override public void onSubscribe(Disposable d) { } @Override public void onNext(Boolean aBoolean) { } @Override public void onError(Throwable e) { countDownTimer.start(); } @Override public void onComplete() { countDownTimer.start(); } }); } 有更新展示更新对话框和下载展示跟新的对话框和使用DownloadManager来下载文件. 对网络的判断和提醒,和下载展示进度条 /** * 显示更新对话框,包含版本相关信息 */ private void showUpdateConfirmDialog(final Context context, final String updateInfo) { new AlertDialog.Builder(context) .setTitle(&quot;发现新版本&quot;) .setMessage(updateInfo) .setPositiveButton(&quot;立即更新&quot;, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { if (NetUtils.isWifi(context)) { downLoadApp(context); } else { // 是不是需要坚持手机网络下载 new AlertDialog.Builder(context) .setTitle(&quot;流量提醒&quot;) .setMessage(&quot;你正在使用移动流量,是否坚持手机网络下载&quot;) .setPositiveButton(&quot;是&quot;, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { downLoadApp(context); } }) .setNegativeButton(&quot;不是&quot;, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { mHandler.sendEmptyMessage(0x10102); } }); } } }) .setNegativeButton(&quot;以后再说&quot;, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { mHandler.sendEmptyMessage(0x10102); } }) .show(); } /** * 下载文件 * * @param context */ public static void downLoadApp(Context context) { //downurl:下载app的后台地址 String downurl = &quot;http://59.110.139.99/apk/fabei.apk&quot;; DownloadManager.Request request = new DownloadManager.Request(Uri.parse(downurl)); // 下载时的网络状态，默认是wifi和移动网络都可以下载，如果选择一个，只能在选中的状态下进行下载 //request.setAllowedNetworkTypes(DownloadManager.Request.NETWORK_MOBILE); request.setNotificationVisibility(DownloadManager.Request.VISIBILITY_VISIBLE); request.setTitle(&quot;app更新&quot;); request.setDescription(&quot;app正在下载&quot;); request.setAllowedOverRoaming(false); //设置文件存放目录 //判断文件是否存在，保证其唯一性 File file = context.getExternalFilesDir(&quot;Download/ccyj&quot;); if (file.exists()) { file.delete(); } request.setDestinationInExternalFilesDir(context, Environment.DIRECTORY_DOWNLOADS, &quot;downapp&quot;); DownloadManager downManager = (DownloadManager) context.getApplicationContext().getSystemService(Context.DOWNLOAD_SERVICE); long id = downManager.enqueue(request); // 存储下载Key SharedPreferences sharedPreferences = context.getSharedPreferences(&quot;downloadapp&quot;, Activity.MODE_PRIVATE); SharedPreferences.Editor editor = sharedPreferences.edit(); editor.putLong(&quot;downloadid&quot;, id); editor.commit(); } 上面中缺失的文件: public class NetUtils { /** * 判断是否是wifi连接 */ public static boolean isWifi(Context context) { ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE); if (null == cm) { return false; } NetworkInfo info = cm.getActiveNetworkInfo(); if (null != info) { if (info.getType() == ConnectivityManager.TYPE_WIFI) { return true; } } return false; } 广播接收者和安装apk下在完成之后会发西湖广播,action是: ACTION_DOWNLOAD_COMPLETE 动态注册广播在上面(注册就有反注册哦,不要忘记了,还有权限都要声明哦): 我们直接看广播接收者中接收后安装apk的操作; public class DownLoadCompleteReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { if (intent.getAction().equals(DownloadManager.ACTION_DOWNLOAD_COMPLETE)) { long id = intent.getLongExtra(DownloadManager.EXTRA_DOWNLOAD_ID, -1); // 发送消息关闭 dialog Message message = new Message(); message.what=1010; EventBus.getDefault().post(message); installApk(context, id); } else if (intent.getAction().equals(DownloadManager.ACTION_NOTIFICATION_CLICKED)) { } } /** * 下载完后安装apk * * @param */ // 安装Apk private void installApk(Context context, long downloadApkId) { SharedPreferences sharedPreferences = context.getSharedPreferences(&quot;downloadapp&quot;, Activity.MODE_PRIVATE); long id = sharedPreferences.getLong(&quot;downloadid&quot;, 0); // 获取存储ID if (downloadApkId == id) { DownloadManager dManager = (DownloadManager) context.getSystemService(Context.DOWNLOAD_SERVICE); Uri downloadFileUri = dManager.getUriForDownloadedFile(downloadApkId); if (downloadFileUri != null) { Intent install = new Intent(Intent.ACTION_VIEW); File apkFile = context.getExternalFilesDir(&quot;Download/downapp&quot;); //对Android 版本判断 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) { install.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); // context.getPackageName() + &quot;.fileprovider&quot; 是配置中的authorities Uri contentUri = FileProvider.getUriForFile(context, context.getPackageName() + &quot;.fileprovider&quot;, apkFile); install.setDataAndType(contentUri, &quot;application/vnd.android.package-archive&quot;); } else { install.setDataAndType(Uri.fromFile(apkFile), &quot;application/vnd.android.package-archive&quot;); } install.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); context.startActivity(install); } else { ToastUtils.showLong(context,&quot;下载失败&quot;); } } } 明天将apk的升级和安转和出现的问题进行总结下载完毕后出现的问题: 出现的是已经安装了存在签名冲突的同名的数据包. 原因如下(一): 我此时是直接测试运行,安装的是debug版本,服务器上的是我打包过的版本,有签名等信息,debug的签名是默认的签名; 先安转以前的签名的版本,在运行一般就不会出错了. 还有问题可以参考下面链接的文章: http://blog.csdn.net/linux_dream_2015/article/details/49890777]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序代码构成学习]]></title>
    <url>%2F2018%2F01%2F26%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BB%A3%E7%A0%81%E6%9E%84%E6%88%90(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[第一次接触到小程序,对于小程序的代码构造和具体的发布情况.是对自己的一个记录. https://mp.weixin.qq.com/debug/wxadoc/dev/quickstart/basic/file.html#JSON-%E9%85%8D%E7%BD%AE 基本实现步凑: https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/new.html 先看小程序的代码构建我们新建的代码的目录和文件大概目录: 主要的样式有如下: 第一个就是 json格式的结尾的配置文件app.json全局配置文件主要的连接地址: https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html 我们这个这个小程序的名称是 龙哥之友. 我们看看app.json里面的目录结构. app.json是对当前小程序的全局的配置.包括小程序的所有的页面的路劲和界面表现,网络超时时间,和底部的tab等. 我们直接看着这个图片进行一一的而了解: pages字段pages: 主要是描述的是当前小程序的多有页面的路劲.目的是告诉微信客户端,相对应的小程序页面定义在那个目录里面. 下面是全部关于 app.json的配置说明: 划重点了 关于 app.json下面的 pages字段:我们常见的就是 文件名不需要写文件后缀，因为框架会自动去寻找路径下 .json, .js, .wxml, .wxss 四个文件进行整合。也就是在index文件夹下面有 index.js和index.wxml和index.wxss 关于window字段 关于window字段:window字段: 小程序的所有页面的背景颜色和文字颜色定义都在这里. 具体的定义如下: 我们展示配置和展示示例的图片展示: 关于tab字段小程序是多页面tab组成的时候,切换时显示相应的页面. 注意点 一 设置的 postion为top时候,不在显示icon图标注意点二: tabBar下面是一个list数组,最少2个最多五个tab,展示顺序和数组顺序一致. tabBr配置的展示: 我们可以看到list的数组对应的就是每一组tab的对象,组成是 pagepath(路劲)和tab上展示的文字. 具体的属性的说明: networkTimeout字段设置网络超时时间; 属性具体的说明: debug字段 page.json页面配置工具配置 project.config.json第二种就是: wxml模板文件第三种第四种文件 json文件]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 个性化配置(三)]]></title>
    <url>%2F2018%2F01%2F25%2FHexo-%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE(%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[本片博客是在上一篇博客Hexo个性化配置(二)的基础上在写的一篇博客,主要不在一起写的原因是,这是自己配置自己搭建的博客时候变学习边记录的文章,记录的比较详细.放置在一篇上面文章比较长,所以截取一次十中个性化的配置.这是第三篇.涉及到如下的个性化配置: jiathis的配置实现博文的分享 文章的置顶功能 打赏功能的实现 点击爆炸效果(有一篇是实现的是红心的效果) github来实现域名的绑定 插入音乐 实现站内搜索 关于404公益页面的实现 DaoVoice在线联系 为博客添加萌萌的宠物 修改评论系统之来比力修改为有言 顺便了解Docker Hexo NexT主题中添加网页标题崩溃欺骗搞怪特效 1.jiathis的分享的实现在主题配置文件下面搜索 jiathis 我们看到在主题的配置文件中已经给我们配置好了,我们需要的是uid; 官网的链接地址: http://www.jiathis.com/ 配置主要的设置: 说明一下子: 我们直接在主题的配置文件中搜索jiathis 直接打开jiathis的开关,配置为true uid丢不需要设置. 最后的结果展示: 2.文章的置顶功能的实现修改插件的内容: 这个插件名称: hexo-generator-index 插件内需要修改文件的名称: generator.js 路劲: /root/blog/node_modules/hexo-generator-index/lib 图片展示: 修改替换的代码: &apos;use strict&apos;; var pagination = require(&apos;hexo-pagination&apos;); module.exports = function(locals){ var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) { if(a.top &amp;&amp; b.top) { // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 } else if(a.top &amp;&amp; !b.top) { // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; } else if(!a.top &amp;&amp; b.top) { return 1; } else return b.date - a.date; // 都没定义按照文章日期降序排 }); var paginationDir = config.pagination_dir || &apos;page&apos;; return pagination(&apos;&apos;, posts, { perPage: config.index_generator.per_page, layout: [&apos;index&apos;, &apos;archive&apos;], format: paginationDir + &apos;/%d/&apos;, data: { __index: true } }); }; 我们还需要在咋子hexo的Front-matter也就是我们创建的Hexo的使用 —分割开的部分区域里面设置top属性值 注意属性设置的时候的空格.数值越大越靠前. 我们在我们的模板中添加top属性,不在我们自己添加了. 路劲: /root/blog/scaffolds修改的文件就是 post.md文件. 添加top属性. 最后设置完毕的展示效果: 3.打赏功能的实现打赏功能一个是微信的我二维码一个支付宝的二维码,我们分别来获取这个两个二维码. 获取微信的打赏二维码,设置金额这个自己设置: 先贴个码. 设置支付宝的打赏二维码和金额 上传图片source/image中在主题配置文件中设置 去掉注释,设置图片就OK了!最后是结果的展示: 4.实现爆炸效果新建js 命名: fireworks.js 放置的路劲: themes/next/source/js/src 代码的内容如下: &quot;use strict&quot;;function updateCoords(e){pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top}function setParticuleDirection(e){var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return{x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)}}function createParticule(e,t){var a={};return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function(){ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()},a}function createCircle(e,t){var a={};return a.x=e,a.y=t,a.color=&quot;#F00&quot;,a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function(){ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1},a}function renderParticule(e){for(var t=0;t&lt;e.animatables.length;t++){e.animatables[t].target.draw()}}function animateParticules(e,t){for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++){n.push(createParticule(e,t))}anime.timeline().add({targets:n,x:function(e){return e.endPos.x},y:function(e){return e.endPos.y},radius:0.1,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule}).add({targets:a,radius:anime.random(80,160),lineWidth:0,alpha:{value:0,easing:&quot;linear&quot;,duration:anime.random(600,800)},duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule,offset:0})}function debounce(e,t){var a;return function(){var n=this,i=arguments;clearTimeout(a),a=setTimeout(function(){e.apply(n,i)},t)}}var canvasEl=document.querySelector(&quot;.fireworks&quot;);if(canvasEl){var ctx=canvasEl.getContext(&quot;2d&quot;),numberOfParticules=30,pointerX=0,pointerY=0,tap=&quot;mousedown&quot;,colors=[&quot;#FF1461&quot;,&quot;#18FF92&quot;,&quot;#5A87FF&quot;,&quot;#FBF38C&quot;],setCanvasSize=debounce(function(){canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+&quot;px&quot;,canvasEl.style.height=window.innerHeight+&quot;px&quot;,canvasEl.getContext(&quot;2d&quot;).scale(2,2)},500),render=anime({duration:1/0,update:function(){ctx.clearRect(0,0,canvasEl.width,canvasEl.height)}});document.addEventListener(tap,function(e){&quot;sidebar&quot;!==e.target.id&amp;&amp;&quot;toggle-sidebar&quot;!==e.target.id&amp;&amp;&quot;A&quot;!==e.target.nodeName&amp;&amp;&quot;IMG&quot;!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))},!1),setCanvasSize(),window.addEventListener(&quot;resize&quot;,setCanvasSize,!1)}&quot;use strict&quot;;function updateCoords(e){pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top}function setParticuleDirection(e){var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return{x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)}}function createParticule(e,t){var a={};return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function(){ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()},a}function createCircle(e,t){var a={};return a.x=e,a.y=t,a.color=&quot;#F00&quot;,a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function(){ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1},a}function renderParticule(e){for(var t=0;t&lt;e.animatables.length;t++){e.animatables[t].target.draw()}}function animateParticules(e,t){for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++){n.push(createParticule(e,t))}anime.timeline().add({targets:n,x:function(e){return e.endPos.x},y:function(e){return e.endPos.y},radius:0.1,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule}).add({targets:a,radius:anime.random(80,160),lineWidth:0,alpha:{value:0,easing:&quot;linear&quot;,duration:anime.random(600,800)},duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule,offset:0})}function debounce(e,t){var a;return function(){var n=this,i=arguments;clearTimeout(a),a=setTimeout(function(){e.apply(n,i)},t)}}var canvasEl=document.querySelector(&quot;.fireworks&quot;);if(canvasEl){var ctx=canvasEl.getContext(&quot;2d&quot;),numberOfParticules=30,pointerX=0,pointerY=0,tap=&quot;mousedown&quot;,colors=[&quot;#FF1461&quot;,&quot;#18FF92&quot;,&quot;#5A87FF&quot;,&quot;#FBF38C&quot;],setCanvasSize=debounce(function(){canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+&quot;px&quot;,canvasEl.style.height=window.innerHeight+&quot;px&quot;,canvasEl.getContext(&quot;2d&quot;).scale(2,2)},500),render=anime({duration:1/0,update:function(){ctx.clearRect(0,0,canvasEl.width,canvasEl.height)}});document.addEventListener(tap,function(e){&quot;sidebar&quot;!==e.target.id&amp;&amp;&quot;toggle-sidebar&quot;!==e.target.id&amp;&amp;&quot;A&quot;!==e.target.nodeName&amp;&amp;&quot;IMG&quot;!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))},!1),setCanvasSize(),window.addEventListener(&quot;resize&quot;,setCanvasSize,!1)}; 之后在themes/next/layout/_layout.swig 添加下面代码: {% if theme.fireworks %} {% endif %} 添加的位置: 在L2Dwidget.init({});前面添加 最后没有实现还是小桃心效果(只是在hexo配置三哪一篇文章的上部实现了这个效果). 最后在主题配置文件中配置: fireworks: true 展示一下: 5.github pages+Hexo搭建具体的总结这个在搭配的时候稍微出现了点问题主要是DNS解析这一块, 上一个搭建完成的 http://kunkun5love.club 至于获取github page 在下面有博文有具体的说明. 主要总结的是 申请域名后将申请的域名通过dns跳转到我们的github page 页面上. 例如: 我的域名是 kunkun5love.club 我获取的github page 的 NYK1024212458.github.io; 实质实现就是浏览器输入 kunkunlove.club 后跳转到 NYK1024212458.github.io,我们将hexo生成的 根目录下面的public目录下的文件上传到我们的仓库中,静态的网址. 第一步将hexo的public 目录上传到NYK1024212458.github.io仓库创建NYK1024212458.github.io仓库(详细在下面) 安装 git(安装Hexo框架的时候初始化了,没有的自己安装),配置秘钥等下面的文章中有详细的步骤 上传public文件到 github 的仓库 操作图片如下: 使用的hexo的命令是 hexo d hexo g 是生成静态的文件 上传上去,此时要是我们访问 NYK1024212458.github.io 已经可以访问,这个访问的域名比较难记,我们使用跳转. 注意 在仓库创建文件 CNAME 内容 : kunkun5love.club也可以在hexo的 source 目录下创建CNAME 文件 内容就是 kunkun5love.club 每一次hexo d 部署到github上的时候会覆盖仓库创建的文件. kunkun5love.club的跳转首先是我们获取我们要跳转的域名的IP地址: 比如我们要跳转 NYK1024212458.github.io,我们ping一下子 操作如下: 打开win+r 输入: cmd 回车 输入 ping NYK1024212458.github.io 回车 (注意NYK1024212458替换这是我的) 接下来就是 域名的dns配置 添加的第一个记录就是 A标记 记录值就是 我们的ip地址 之后添加一个 CNAME 标记 记录值就是 NYK1024212458.github.io 如果出现问题在下面展示的标志位置不会显示连接: git的安装和email和name的配置这个操作有自己的详细的博客地址: http://blog.csdn.net/kunkun5love/article/details/71915498 注册github来创建 repositories注册github,根据提醒注册一个github,操作失败的请移步下面的连接地址:https://baijiahao.baidu.com/s?id=1573372372409235&amp;wfr=spider&amp;for=pc, 进入自己的页面;图片展示如下 进入创建的页面,展示如下: 点击new repositories 创建来获取github page 说明一下子: 新建的名字必须和你github上面的名称一致,将上面NYK1024212458修改为你的github账户就行,结尾.github.io结尾,我已经创建过一次,这一次只是为了展示说明,注意要初始化一个Readme的文件,也就是最后一个要勾选. 创建完毕就是获取我们创建仓库的github page ,进入我们刚刚创建的仓库,点击setting 获取githubpage: 首先是自己的创建的gitpage https://nyk1024212458.github.io/ 访问的结果如此: 获取ssh,后面在hexo的主题配置中会使用到 ssh: git@github.com:NYK1024212458/NYK1024212458.github.io.git 将我们申请的其他域名与github申请的空间绑定首先是在github上面的 刚获取的githubpage里面新建一个文件名称是 CNAME 没有后缀,内容就是我们在阿里云或者是其他地方申请的域名,至于域名现在都要实名制,要备案,这些有官方的说明,按着操作就可以了. 例如我的域名在腾讯云上申请的 kunkun5love.tk ,我们CNAME 里面的内容就是 kunkun5love.club 这个CNAME需要上传到我们的初始化的Hexo的博客文件中去,位置就是 初始化的文件夹(执行 hexo init 文件夹的名称) /source 下面 展示如下: 设置自己域名的DNS设置 推荐的是DNSpod: 连接地址: https://www.dnspod.cn/ 首先是添加你申请的域名,之后是添加解析: Hexo中的配置安装的扩展插件: npm install hexo-deployer-git --save 展示图片: 在站点配置文件的设置: 6.插入音乐进入网页版的歌曲页面获取外部播放连接我们首先是登录网易云: http://music.163.com/ 点击自己要插入音乐的首页: 目的是获取播放的外链 展示如下: 直接复制歌曲的播放代码到博客中复制代码,直接到博客中: 我复制的代码如下 &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86 src=&quot;//music.163.com/outchain/player?type=2&amp;id=34383004&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt; 下面的是flash代码: &lt;embed src=&quot;//music.163.com/style/swf/widget.swf?sid=34383004&amp;type=2&amp;auto=1&amp;width=320&amp;height=66&quot; width=&quot;340&quot; height=&quot;86&quot; allowNetworking=&quot;all&quot;&gt;&lt;/embed&gt; 我们上传到hexo试试: 说明一下子,win10自带的浏览器是两种都支持的,火狐flash插件的问题,不能播放. 抽时间写一篇关于火狐flash的处理. 7.增加一个站内搜索站内的搜索功能是一直在处于可以出现搜索,但是输入搜索的内容没有反应,今天重新开始写搜索的功能. 参考的博客的地址: http://theme-next.iissnan.com/third-party-services.html#algolia-search 使用的还是 algolia 注册和新建获取全部相同. 申请第三方的账号https://www.algolia.com/ 使用的邮箱是自己的qq邮箱 1024212458@qq.com 获取秘钥: 我们需要的只是仅仅用来搜索的页面 ip: ,,,,,,(不展示了) 新建搜索的index文件 输入新建的index的名称,后面会在主题的配置文件中配置. 设置权限点击API KEY页面,点击 ALL API KEYS 设置权限 点击编辑之后的权限设置: 图片展示如下: 按照上面的设置就行可! 上传数据到algolia执行命令: npm install hexo-algolia --save 安装展示图片: 站点配置站点配置的数据就是我们在algolia注册在 apikey的数据 展示如下: 站点配置文件的配置: 执行命令 hexo algoliahexo algolia 刚开始的直接执行下面的这个命令报下面的错误: 错误展示如下: 解决的办法: linux系统使用export windowns系统使用gitbash 配置主题文件 最后成功的展示图片: 8.关于404公益页面的实现我们在前面实现了域名跳转到github page页面 我们实现的是腾讯的404页面 连接地址: http://www.qq.com/404/ 主要的操作就是复制里面的js代码到我们的404页面中. 在hexo的source 里面新建404.html 编写html文件: 代码复制: &lt; !DOCTYPE html&gt; &lt;html lang =&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;404页面&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 我们上传后,配置我们主页的404显示界面,直接指定到404.html文件,配置如下: 最后博客的展示页面: 最后来一个参考博客: http://www.foreverpx.cn/2014/09/23/hexo404/ 9.DaoVoice实现在线联系绝佳的用户沟通工具 注册登录填写邀请码注册登录地址如下: http://www.daovoice.io/ 官网进行注册,需要邀请码: 0f81ff2f 复制粘贴就可以了~! 展示的图片如下: 复制粘贴代码修改的hexo的文件路劲如下: themes/next/layout/_partials/head.swig 添加下面的代码: {% if theme.daovoice %} (function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0eeeae6f.js","daovoice") daovoice('init', { app_id: "你获取的appid" }); daovoice('update'); {% endif %} 展示如下: 修改主题的配置文件在主题的配置文件中添加: daovoice: true daovoice_app_id: 我们注册获取的id 结果没有显示出来展示如下: 其他的没有什么改变,要是你也是和我一样出现这样的情况,第一我是检查我的主题配置文件: 将daovoice不要出现书写错误 第二点就是,我将上面的代码,直接放在最前面,最后hexo clean 重新部署就OK了! 聊天对话款和欢迎词的设置 登录到Dao voice 的官网在应用设置中设置: 展示如下: 10.为博客添加萌萌的宠物 #\添加的是宠物信息. 第一步切换终端输入下面命令 安装live2dnpm install -save hexo-helper-live2d 安装展示的图片如下: 修改_layout.swig文件修改文件的路劲如下: themes/next/layout/-layout.swig文件 路劲展示如下: 修改的代码如下: {{ live2d() }} 主题配置文件中进行配置 注释掉是在底部挡住了在线聊天的那个图标. 最后是图片的展示页面: 11.修改评论系统之来比力修改为有言来比力的配置在上面的Hexo的个性化配置中有说明,现在是修改为有言的操作记录(Hexp的配置文件中都集成了,需要配置uid). 官网地址: http://www.uyan.cc/ 展示图片: 在主题配置文件中配置: youyan_uid : 自己设置的uid 这样设置来比力是没有问题的,有言设置之后没有显示出来. 12.DaoCloud的了解首先就是在官网注册: DaoVoice的官网的连接地址如下: https://account.daocloud.io/signin 展示图片如下: 我直接使用的是github的账户来登录的: Talk is cheap,show me the code: 空谈误国,实干兴邦 Eat your own dogfood : 做好自己 DaoKer Day: 日复一日 顺便学习了Dockerhttp://guide.daocloud.io/dcs/docker-daocloud-9153164.html 上面的连接说的很是直接明白,这里自己摘取一些作为自己 的笔记. Docker image 和Dockerfile Docker image 相当于就是我们安转系统时候说的镜像(image),系统的Ghost是对系统一些设置和安装软件后的设置进行clone的备份,在Docker中 是对Docker image 的修改写在了 Dockerfile中然后 构建为一个新的Docker image ,这些对软件或者系统等的修改或者是安转软件的操作此时还是没有运行生效的,只不过在 构建完成的Docker image在 容器中运行的时候才会生效 ,而Docker node就是提过容器的. Docker image就是镜像 Dockerfile里面记录的就是对镜像的操作, Docker node提供的就是容器. 源Docker Image 在Dockerfiler里面的命令 构建一个新的Docker image 就是一个构建的过程. 让Docker image 运行 在container中, 将 Docker image 调入容器运行的动作叫做 是 部署 . Docker 软件就是 下载 安装 配置的 Dockere server 是一个虚拟化的软件.Docker node Docker node 就是安装了Docker软件的硬件机器,从而成为Docker虚拟机母平台. 13.Hexo NexT主题中添加网页标题崩溃欺骗搞怪特效是一个js特效: 创建js在next\source\js\src文件夹下创建crash_cheat.js，添加代码： &lt;!--崩溃欺骗--&gt; var OriginTitile = document.title; var titleTime; document.addEventListener(&apos;visibilitychange&apos;, function () { if (document.hidden) { $(&apos;[rel=&quot;icon&quot;]&apos;).attr(&apos;href&apos;, &quot;/img/TEP.ico&quot;); document.title = &apos;╭(°A°`)╮ 页面崩溃啦 ~&apos;; clearTimeout(titleTime); } else { $(&apos;[rel=&quot;icon&quot;]&apos;).attr(&apos;href&apos;, &quot;/favicon.ico&quot;); document.title = &apos;(ฅ&gt;ω&lt;*ฅ) 噫又好了~&apos; + OriginTitile; titleTime = setTimeout(function () { document.title = OriginTitile; }, 2000); } }); 在_layout.swig中的使用&lt;!--崩溃欺骗--&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/crash_cheat.js&quot;&gt;&lt;/script&gt; 最后实现: 展示效果: kunkun5love.club]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo的个性化配置(二)]]></title>
    <url>%2F2018%2F01%2F22%2FHexo%E7%9A%84%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[Hexo的个性化配置二接上一篇的Hexo的个性化配置,都是一些提高网站个性化的配置,只是搭建一个简单的Hexo的网站的话,查看Hexo的使用就行.可能写的比较啰嗦,详细还是很详细的,也是自己就出Hexo的一个记录. 1.Hexo之文章阅读结束后出现 感谢大家的阅读!添加新的文件修改下面路劲下的文件: /themes/next/layout/_macro 路劲下新建文件: 文件名称: passage-end-tag.swig 并且添加下面内容的标签-内容如下: &lt;div&gt; {% if not is_index %} -------------本文结束感谢您的阅读!------------- {% endif %} &lt;/div&gt; 将新建的添加到 post.swig文件中文件的路劲: themes/next/lauyout/_macro/post.swig 文件中. 展示图片: 注意 我没有在主题的配置文件中添加下面的代码最后也显示正常.我试试配置之后出现什情况. 配置的如下: # 文章末尾添加“本文结束”标记 passage_end_tag: enabled: true 最后的结果是也没有什么变化,如果大家设置完毕之后出现不显示字体,可以尝试在主题的配置文件中添加这个配置,虽然不一定可以解决这个问题,也算是一种尝试. 2.实现点击个人图标实现图片的旋转在主题下面的资源中修改工具栏的样式. 路劲: themes/next/source/css/_common/components/sidebar/sidebar-author.style 路劲的展示图片: 添加的代码如下: /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out; } img:hover { /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg); } /* Z 轴旋转动画 */ @-webkit-keyframes play { 0% { -webkit-transform: rotateZ(0deg); } 100% { -webkit-transform: rotateZ(-360deg); } } @-moz-keyframes play { 0% { -moz-transform: rotateZ(0deg); } 100% { -moz-transform: rotateZ(-360deg); } } @keyframes play { 0% { transform: rotateZ(0deg); } 100% { transform: rotateZ(-360deg); } } 添加的位置如下: 结束位置如下: 3.文章中代码块的样式的自定义之前的样式展示: 修改的演示的路劲: /root/blog/themes/next/source/css/_custom下面的custom.styl文件 添加的内容如下: // Custom styles. code { color: #ff7600; background: #fbf7f8; margin: 2px; } // 大代码块的自定义样式 .highlight, pre { margin: 5px 0; padding: 5px; border-radius: 3px; } .highlight, code, pre { border: 1px solid #d6d6d6; } 最后的展示结果表示很难看,连接划过之后变成黄色.大段的代码块非常的难看. 自己最后注释掉自定义的样式. 4侧边脸社交图标的设置修改的是主题配置文件: 关键字就是: social 社交的意思 自己可以选择的图标的库: http://fontawesome.io/icons/ 最后自己的配置: 结果的展示: 5.在网站的底部加上访问数量修改的代码途径: /themes/next/layout/_partials.swig 文件 js代码如下: &lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 这个url地址: https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js 访问后的展示图片如下: 添加访问的统计的代码: &lt;div class=&quot;powered-by&quot;&gt; &lt;i class=&quot;fa fa-user-md&quot;&gt;&lt;/i&gt;&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 我的网站的访客数:&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt; &lt;/span&gt; &lt;/div&gt; 图片的展示: 最后展示结果: 6.实现网站底部对字数的统计第一步安装wordcount在博客的根目录下面执行下面的命令: npm install hexo-wordcount --save 安装展示图片: 之后修改的文件的位置; 然后在/themes/next/layout/_partials/footer.swig文件尾部加上： &lt;div class=&quot;theme-info&quot;&gt; &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt; &lt;span class=&quot;post-count&quot;&gt;博客全站共{{ totalcount(site) }}字&lt;/span&gt; &lt;/div&gt; 放置的位置的展示图片: 直接放置在最后面就可以了! 最后的展示页面: 快速安装插件后在主题配置文件中开启文章的字数统计和站点的字数统计和阅读大体的时长还有就是阅读时间等在我们安装上面的插件之后,可以在主题的配置文件中开启. 我们看到是wordcount是关闭的,和阅读时间都是关闭的.我们打开看看. 最后是展示结果 我们可以看到文章的字数统计和阅读的时长 我们在可以看到一个是主题配置之后出现的全站的字数,一个是自己在foot.swig文件中配置后出现的效果. 7.实现访问博客时候在展示的图标favicon : 英文含义就是网站图标 也就是在访问博客的时候在浏览器上显示的图标标就是现在设置的图标.格式都是 .ico的格式. 选择格式的连接地址: http://www.easyicon.net/ 大小是 32*32px的大小; 之后下载,重命名为 favicon.ico格式. 之后的操作就是在主题的配置文件中进行配置. 图片上传的位置: themes/next/source/image 并且在主题的配置文件中进行配置: favicon: small: /images/favicon.ico medium: /images/heart_bulb_stars_16px_1209625_easyicon.net.ico 图片的展示: 说明一点,在hexo 3.0之后 主题配置文件中对于网站的图标的展示分大小 small 和medium ,在上面的选择图标的位置选择1616px和3232px的,上传,在主题配置文件中设置就OK了. 原先的图片展示: 修改后图片展示: 8.添加网页顶部的加载条在最新的hexo 3.0 中可以直接在主题的配置文件中修改: 看到 pace 是false我们直接修改为true 后面的都是加载的样式,我们可以自己选择. 注意的是 pace_theme: 才是我们选择的. 暂时没有实现,不知道哪里的设置出错了. 9.文章底部添加版权信息第一个新建的问价路劲如下:themes/next/layout/_macro 新建文件 my-copyright.swig 文件 添加的代码如下: {% if page.copyright %} 本文标题:{{ page.title }} 文章作者:{{ theme.author }} 发布时间:{{ page.date.format("YYYY年MM月DD日 - HH:MM") }} 最后更新:{{ page.updated.format("YYYY年MM月DD日 - HH:MM") }} 原始链接:{{ page.permalink }} 许可协议: 署名-非商业性使用-禁止演绎 4.0 国际 转载请保留原文链接及作者。 var clipboard = new Clipboard('.fa-clipboard'); $(".fa-clipboard").click(function(){ clipboard.on('success', function(){ swal({ title: "", text: '复制成功', icon: "success", showConfirmButton: true }); }); }); {% endif %} 第二个新添加的文件:路劲如下: themes/next/source/css/_common/components/post/my-post-copyright.styl : 代码如下: .my_post_copyright { width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4); } .my_post_copyright p{margin:0;} .my_post_copyright span { display: inline-block; width: 5.2em; color: #b5b5b5; font-weight: bold; } .my_post_copyright .raw { margin-left: 1em; width: 5em; } .my_post_copyright a { color: #808080; border-bottom:0; } .my_post_copyright a:hover { color: #a3d2a3; text-decoration: underline; } .my_post_copyright:hover .fa-clipboard { color: #000; } .my_post_copyright .post-url:hover { font-weight: normal; } .my_post_copyright .copy-path { margin-left: 1em; width: 1em; +mobile(){display:none;} } .my_post_copyright .copy-path:hover { color: #808080; cursor: pointer; } 修改的文件一修改的文件路径: next/layout/_macro/post.swig 文件 添加的代码如下: &lt;div&gt; {% if not is_index %} {% include 'my-copyright.swig' %} {% endif %} &lt;/div&gt; 添加的路劲如图所示: 修改的文件二在修改一个文件: 路劲如下: next/sources/css/_common/components/post/post.styl 具体的展示图片如下: 最后一步就是设置 copyright: true 我们可以修改一下子模板 根目录/scaffolds/post.md文件. 最后的结果展示: 10.隐藏底部的强力驱动 power by hexo修改的就是是 footer.swig 文件 路劲: themes/next/layout/_partials/footer.swig 结果展示:]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo的个性化配置(一)]]></title>
    <url>%2F2018%2F01%2F17%2FHexo%E7%9A%84%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[本片博客是在集成Hexo的博客大家之后的一些个人性话的操作,也是自己的一个学习笔记,从操作到图片的展示,每一个个性化操作都比较详细,例如Hexo的评论集成,Rss订阅到Fork me on github的操作和添加动态背景图等;点击出现桃心的效果和文章加密访问等. 1.Hexo评论集成学习的连接博客地址: http://blog.csdn.net/qwerty200696/article/details/78836421 这里面集成的是来必力的评论系统. 具体的操作过程: 打开来比力的官网连接地址如下: https://livere.com/ 注册来必力的官网. 也就是邮箱别名和登录密码,之后就是 验证登录; 成功后的页面如下: 安装来比力city版 点击上面的安装进行来比力的安装. 我们使用的当然是免费的版本city. 点击现在安装之后出现的界面: 在这里解释一下子:网站的连接就是你要设置的网页的地址: 我填写的是自己的博客地址: http://116.196.91.100:4000/ 网站名称: 自己的博客名称 网站的类型: 个人. 获取申请的代码点击获取代码: 在我们的hexo的主题中进行配置我使用主题是next, 我们在我们博客的初始化文件夹中寻找 theme 进入找到 next 打开,对_config.yml打开进行配置: 修改完毕.我们仔细看,还有一个可以配置的commit系统,有言后面是对应的地址,我们可以直接访问获取uid之后进行配置. 最后一步就是在hexo的页面开启就是在设置tags等出,设置 comments: true 注意空格 最后设置成功后的展示页面 2.设置Fork me on Github具体的步骤如下: ##第一步选取适合自己的样式代码## 第一种样式的展示图片:选取的样式代码的连接在如下的地址(显示的样式字母 fork me on github): https://github.com/blog/273-github-ribbons 还有一种样式就是图标的样式的选取: 图标的展示图片: 代码的连接地址如下: http://tholman.com/github-corners/ 根据上面的样式和颜色选择自己的喜欢的样式进行代码的复制. 在主题中进行配置/root/blog/themes/next/layout/_layout.swig文件中进行配置 /root表示的是根目录. next表示的是当前你使用的主题的样式. 具体的配置直接图片中展示: 注意的是: href 后面是自己的github的地址,记得修改哦! 最后就是结果的展示页面: 3.设置Rss订阅Rss 是什么东西: 来,百度百科连接走一趟: https://baike.baidu.com/item/rss/24470?fr=aladdin#12 用途: 具体的操作过程就是安装Hexo的插件 安转hexo的feed(消息源,类型分为Rss和Atom两种)安装的位置就在你hexo init初始化的位置,我是直接 hexo init blog,会在根目录下面生成一个blog文件,进入blog进行安装插件. npm install --save hexo-generator-feed 安装结束的展示图片: 在站点配置文件中进行配置打开站点的配置文件在最后一行中添加下面的配置: plugins: hexo-generate-feed 还需要的操作就是 配置主题配置文件next的主题配置文件修改_config.yml文件中添加: rss: /atom.xml 最后就是结果的展示图片: 4.文章的输入密码访问第一步修改主题下面的文件主要的是修改的主题下面的文件: themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig 我使用的next主题 还需要注意的就是这里面的是head.swig 文件不是header.swif文件. 不然是找不到位置的. script代码如下: &lt;script&gt; (function(){ if(&apos;{{ page.password }}&apos;){ if (prompt(&apos;请输入文章密码&apos;) !== &apos;{{ page.password }}&apos;){ alert(&apos;密码错误！&apos;); history.back(); } } })(); &lt;/script&gt; 在需要加密文章的页面的配置信息在页面的配置如下: 在文字页面设置的密码就是需要访问的时候输入的密码. 最后的展示结果展示: 5.关于添加动态页面的设置关于动态页面的设置: 先上一个连接地址: 我大体的描述一下子: 若果存在canvas_nest直接在主题配置文件中搜索: canvas_nest 若是存在直接设置为true,说明使用的next版本是在5.1.1之上. 在主题配置文件中不存在若是在主题的配置文件中没有找到这个文件,那就哪找上面的连接地址来设置. {% if theme.canvas_nest %} {% endif %} 将上面的代码添加到 next/layout/_layout.swig文件中 具体的位置如下: 在 L2Dwidget.init({});之前添加代码(注意不要放在的后面) 之后在主题的配置文件中配置: canvas_nest: true 实现点击的桃心效果添加打js代码地址: http://7u2ss1.com1.z0.glb.clouddn.com/love.js 获取js代码获取到的js代码: !function(e,t,a){function n(){c(&quot;.heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: &apos;&apos;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}&quot;),o(),r()}function r(){for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)}function o(){var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e){t&amp;&amp;t(),i(e)}}function i(e){var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,d.push({el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()}),t.body.appendChild(a)}function c(e){var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try{a.appendChild(t.createTextNode(e))}catch(t){a.styleSheet.cssText=e}t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)}function s(){return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;}var d=[];e.requestAnimationFrame=function(){return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e){setTimeout(e,1e3/60)}}(),n()}(window,document); 新建js代码放置在/theme/next/source/js/src这个路劲下面,新建love.js,将上面的代码复制进去. 代码放置位置的展示: 配置 _layout.swig文件在 themes/next/layout/_layout.swig 文件, 最后部分添加: &lt;!-- 页面点击小红心 --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt; 在_layout.swig位置的设置展示: 最后效果的展示区域: 6.修改文章内连接的样式修改的就是我们在文章中写的关于条状的连接. 修改的文件路劲: themes/next/sources/css/_common/components/post/post.styl 文件; 添加的css 的样式如下: .post-body p a{ color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover { color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; } } 注意的是: 这个点不要忘记了.选择.post-body 是为了不影响标题，选择 p 是为了不影响首页“阅读全文”的显示样式. 7.关于Hexo搭建博客的分类分类: categories 展示图片: 第一步是在主题的配置文件中打开 新建对应的pagehexo new page categories hexo new page tags 之后就是重新的部署; 会在/sources下面生成对应的文件夹,里面对应的是 index.md文件 修改index.md文件 我们点击分类的时候会将对应的文件夹里面的index.md文件转化为网页展示出来,我们需要在 index.md中添加的就是类型: type: categories/tags 在文章中的处理对应的我们在新建文章之后需要的是在 顶部设置 tags或者是categories 是什么的类型. 我们在文章中设置的会在进行分类或者是标签归类在一起. 文章的设置展示样例: 8.Hexo之站点地图的搭建sitemap.xml也算是第一次接触到站点地图;那么什么是站点地图; 百度走一波: https://baike.baidu.com/item/%E7%AB%99%E7%82%B9%E5%9C%B0%E5%9B%BE/9991876?fr=aladdin 自己话语总结一下子站点地图: 在Hexo初始化的位置执行下面的命令 命令如下: npm install hexo-generator-sitemap --save 安装百度的sitemap: 重新部署点击就可以看到生成的sitemap.xml 如果部署后没有显示则在站点配置文件中配置站点配置文件中配置: # sitemap sitemap: path: sitemap.xml baidusitemap: path: baidusitemap.xml 学习的连接地址: http://viggoz.com/2016/05/17/2016-05-17-hexo3/ 成功生成站点地图文件的展示 如上设置,出现,sitemap.xml和baidusitemap.xml 表示站点文件生成. 之后就是百度站点地图的验证百度站长平台进行验证: https://ziyuan.baidu.com/dashboard/index 第一次会输入一些信息,姓名,职位等信息. 后面就是添加站点: 之后就是站点属性: 最后就是验证网站. 验证的方式都有详细的说明. 下载放置到网站的根目录: 9.配置站点地图后出现的hexo s 命令失效的解决办法 注意了,我们的是这个服务器上还有一个网站,验证的时候出现自动跳转到那个网页上去,验证失败.而且今天发现我进入 hexo初始化的文件夹里面执行hexo s 的时候出现hexo s 命令不能使用. 展示一下子我自己的hexo的版本: 问题出现的描述: 最后查找单独安装了hexo server ,最后还是老样子,没有解决,看到说在站点的配置文件中不要什么插件的声明,我们想到在设置站点配置文件 的时候出现过对插件的配置. 最后的处理如下: 在站点的配置文件中对插件的声明全部注释掉. 最后完美解决. 10.修改文章后面标签的图标原先图标的展示页面: 修改模板: 在主题下: themes/next/layout/_macro/post.swig文件: 具体的修改位置: 搜索 rel=”tag”&gt;#，将 # 换成 最后是修改完成的展示:]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo的使用]]></title>
    <url>%2F2018%2F01%2F17%2FHexo%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言: 一直对hexo的风格所喜欢者,只是在开始的时候选择阴差阳错的选择了workpress ,搭建的博客也是很好使用,最近看到一篇关于hexo搭建的网页,我觉得我还是在来折腾一次,趁着年轻,赶快折腾. Hexo的安转首先是你有自己的云主机; 其次就是你使用软件登录进去,这些我前面都有自己的文件. 我们手下是xshell进行登录: 安转gitLinux (Ubuntu, Debian)：sudo apt-get install git-core Linux (Fedora, Red Hat, CentOS)：sudo yum install git-core 上面对Linux根据不同使用到的安装git的命令. 之后就是安转nodes 连接地址: (hexo的使用手册)https://hexo.io/zh-cn/docs/index.html 根据这个手册在使用的时候出现的信息是不是我所想要的, 执行安转nodes 的第二个命令的时候出现了错误. 其实我们不需要自己输入,直接复制在到xhsell中右击粘贴回车就ok了! 图片一 使用到的命令行如下: https://hexo.io/zh-cn/docs/index.html https://hexo.io/zh-cn/docs/index.html 之后的操作就是重启连接终端,执行命令进行安转hexo nvm install stable 安装Nodes.js之后我们才开始安装Hexo 安装Hexo直接复制命令行进行安装: npm install -g hexo-cli 之后就是安装的hexo的初始化等的操 我们是安装在/opt/hexoflolder文件夹下面.我们使用xftp看看安装完成后的目录结构. 使用到的命名行如下: $ hexo init &lt;folder&gt; $ cd &lt;folder&gt; $ npm install 第一次安装之后的访问地址在这次是我自己的服务器外地址的: 自己服务器的ip地址: 116.196.91.100 我们的访问网址: http://116.196.91.100:4000/ 对我们直接访问就可以了! 我们在访问这个地址的时候我们首先要保证的是hexo的服务是不是启动的,启动之后我么 访问才能访问到. 我们首先要进入的是hexo的root很目录,这里面是blog在输入: hexo s 访问成功: 按照简书的学习一边再做总结新建一个页面(进入到blog根页面) hexo new &quot;页面的名称&quot; 此时会生成一个”页面名称”.md 的文件,地址在:/root/blog/source/_posts 展示如图: 以后生成的所有的页面都会在这个文件中有对应的md文件. 之后的操作就是使用 hexo generate 生成静态的文件,这个命令的含义是将md文件转化为html文件. hexo generate 之后在blog/public的目录下面会有对应的html. 2018里面就是刚才的新建的页面你的html. 展示的结果 总结: 以后新建页面的时候 使用 的命令分别是 hexo new &quot;post的提交的页面的名称&quot; 之后修改里面的内容. 只有生成静态的文件: hexo generate 之后启动页面 : hexo s (hexo server) 绑定独立的域名安装next主题第一步 git pill next主题我们首先进入的是我们的hexo的根目录:(这里是进入 blog) git clone https://github.com/iissnan/hexo-theme-next themes/next 回车,等待完成: 第二步 配置主题 修改为next主题 清楚缓冲,并且开启debug服务 hexo clean 开启debug的服务 hexo s --debug ok,不在展示了! 修改主题的scheme 注意修改的主题配置文件 是在根目录下面的 theme文件夹下面 我们打开next目录,之后的我们修改配置文件 下面的scheme 修改主题的文字支持 注意修改的是站点配置文件 修改的是language: zh-hans (注意配置文件都需要空一格之后再书写) 出错了,明天解决问题的展示: 对于这个问题,我只是修改了站点的配置文件为 语言的设置,还有就是设置的是主题的配置文件,最后重新运行之后出现的错误, 查询之后出现的问题是,在配置文件的时候需要 空一格在书写相应的配置信息. 重新修改配置信息.空格之后开始相应的配置. 重新运行就可以了! 设置主题 修改的文件是主题配置文件 其他的问题修改hexo的默认端口,第一个就是在站点配置文件中添加下面的代码: server: port: 4001 (自己任意填写) compress: true header: true 第二个就是直接使用命令行来修改: 进入根目录: hexo server -p(自己喜欢的端口) 之后重新运行,就ok,访问的地址变成: http://116.196.91.100:40001/ 后台运行 hexo s &amp; http://www.tuijiankan.com/2015/05/08/hexo-forever-run/ 关于hexo的菜单的设置菜单的显示如下三部分: 第一部分是设置菜单的内容 在主题配置文件中: menu: home: about:/about/ ||user (user表示的就是展示的图标)这里设置的不会显示在页面,而是根据这里的字段去我们在站点配置文件中设置的语音找对应字段去解析出来的文字才是战士的额文字.第二部分解析文字比如我们在我们的站点配置文件中设置的语言是 zh-Hans,之后会在theme这个文件下面的next主题下寻找 zh-Hans.yml去解析 home对应的文字解析, 第三部分解析图标menu-icon 表示的就是对于解析的图标.其中 enable 表示的是对图标展示的控制 true 表示的就是显示图标 false表示就是不显示图标 关于主题的推荐 https://www.zhihu.com/question/24422335 next主题的使用文档:http://theme-next.iissnan.com/ 傻瓜式安装搭建博客https://portablehexo.bitmoe.cn/ 关于头像的设置修改的主题配置文件 avatar 创建page首先是 进入根目录 hexo new page about 之后就会生成相对应的page页面,这个页面不是文章页面不会显示在页面列表中. 此时会在 resource目录下生成about 文件,并且生成index.md文件 部署就行了. 记录一下子自己的配置的 图片有几点需要在此记录一下子. 首先是图片这个菜单项的添加和初见这个页面文字的居中展示和分类标签的设置. 一个就是菜单的图片的显示 说明一下子,我使用的主题是 next 主题. 其他的站点配置不需要更改,我们需要的是修改主题页面 下的_config.yml配置文件. 在menu 下面 添加photo: /categories/图片 然后在主题的lauguage目录下找到你在站点配置文件下面设置的站点的语言信息,比如我在我的站点的语言配置的是zh-Hans ,在next主题下面的languange文件夹下面寻找到 zh-Hans.yml 在里面添加解析字段: 主题文档的文字解析: 你们看到我在menu下面添加的 photo: 图片 注意的是在设置配置的时候 需要的而是空一格在填写. 我们在看一个图片: 这个是我们新建文章的时候 layout的类型,默认是post类型: page.md是页面,会在sources下面创建对应的文件夹,生成index.md文件. draf.md 是我们文章的草稿就是这个类型. 新建photo.md类型,里面的格式如下: 新建一个文章 hexo new layout phot “初见” 关键点就是在这个文章md中添加: categories: 图片 试试直接新建一个页面 不适用photo 只是添加分类为图片,我们看看最后测试,只要设置了 categories: 图片 都会分类到图片这个菜单下. 配置文字居中显示学习连接: https://hexo.io/zh-cn/docs/tag-plugins.html 文字居中两种使用: HTML方式: 给img添加属性 class=”blockquote-center” 标签的方式使用 : 使用的标签是 centerquote或者是 cq 使用样例: &lt;!-- 标签 方式，要求版本在0.4.5或以上 --&gt; {% centerquote %}blah blah blah{% endcenterquote %} &lt;!-- 标签别名 --&gt; {% cq %} blah blah blah {% endcq %} 突破容器宽度限制的图片 作用: 图片自动扩大26%,并突破文章容器的宽度.使用的方式两种: HTML 使用 添加 class=”full-image” 标签的使用方式: 第一种html方式 &lt;!-- HTML方式: 直接在 Markdown 文件中编写 HTML 来调用 --&gt; &lt;!-- 其中 class=&quot;full-image&quot; 是必须的 --&gt; &lt;img src=&quot;/image-url&quot; class=&quot;full-image&quot; /&gt; 第二种方式: &lt;!-- 标签 方式，要求版本在0.4.5或以上 --&gt; {% fullimage /image-url, alt, title %} &lt;!-- 别名 --&gt; {% fi /image-url, alt, title %} 我习惯是在md文件中直接引用图片的文件,这样设置我们成功. 设置文章的摘要设置阅读更多的操作: 方式有三种: 第一种是使用 之歌标志之前的会作为简介来展现,出现点击阅读全文的字样. 在文章的 front-matter(hexo中–之间的的文字描述—) 中添加description,,,,,,具体的格式是如下: description: 这是我要展示的简介文字 第三个就是 配置主题文件的配置文件 auto_excerpt” enable: true length: 150(表示截取的长度是150字符,也是默认的) 最后关于tags和categories首先是tags 是会展示在文章的最后的 开头是#区别 categories是分类,展示在文档的首页.]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F01%2F17%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 关于迟到迟到后的心理: 朋友圈的图片展示: 迟到后的处理: 及时是迟到了,不做别的,尽量早点赶到. 还有就是已经迟到了,无所谓了,吃个早餐慢慢的到达,反正是迟到了! Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[初见]]></title>
    <url>%2F2018%2F01%2F11%2F%E5%88%9D%E8%A7%81%2F</url>
    <content type="text"><![CDATA[图片的展示区域: 只是展示:图片壁纸:]]></content>
      <categories>
        <category>图片</category>
      </categories>
      <tags>
        <tag>图片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/UDP编程]]></title>
    <url>%2F2018%2F01%2F10%2F%E6%B5%8B%E8%AF%95%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[TCP/UDP编程在最近的无线模组的开发中对于TCP和UDP的协议的要求有了进一步的需求,这片博客是自己学习基础的一片博客,用于自己以后在学习过程中的查看和基础回顾.话说最近是不是该歇一歇面试的知识点整理了! 基础知识点详解:第一个基础知识就是OSI模型的展示:osi一直在说,今天来看看osi(open System Interconncetion,OSI/RM,Open System Interconnection Reference Modle): OSI模型，即开放式通信系统互联参考模型(Open System Interconnection,OSI/RM,Open Systems Interconnection Reference Model)，是国际标准化组织(ISO)提出的一个试图使各种计算机在世界范围内互连为网络的标准框架，简称OSI。 注意这几个缩写 ios(苹果公司的移动操作系统); iso(国际标准化组织) OSI(osi模型) OSI将计算机网络体系结构(architecture）划分为以下七层;这也就是我们常说的osi七层协议: 下面的是百度百科关于各层的说明(通俗易懂) 物理层(Physical Layer): 将数据转换为可通过物理介质传送的电子信号 相当于邮局中的搬运工人 数据链路层(Datalink Layer): 决定访问网络介质的方式在此层将数据分帧，并处理流控制。本层指定拓扑结构并提供硬件寻址。相当于邮局中的装拆箱工人 网络层(Network Layer): 使用权数据路由经过大型网络 相当于邮局中的排序工人(ip协议) 传输层(Transport Layer): 提供终端到终端的可靠连接 相当于公司中跑邮局的送信职员 会话层(Session Layer): 允许用户使用简单易记的名称建立连接 相当于公司中收寄信、写信封与拆信封的秘书 表示层(Presentation Layer): 协商数据交换格式 相当公司中简报老板、替老板写信的助理 应用层(Appliication Layer): 用户的应用程序和网络之间的接口老板 数据传输数据包的概念: 数据包是一个信息单位，作为一个整体，从网络中的一个设备传送给另一个设备。 数据包是在应用层创建的,从上向下一层一层的传递,每一层对数据包重新的组装. 数据包的格式: 数据包结构 数据包包含了几种不同类型的数据： 信息，某种类的计算机控制数据和命令- 会话控制代码 数据包头 数据 报尾 创建数据包 数据包的创建过程是从OSI模型的应用层开始的。跨网络传输的信息要从应用层开始，往下依次穿过各层。每层都对数据包进行重新组装，以增加自己的信息（信头）。 TCP/UDP的缩写(在传输层上(第四层))TCP(Transmission Control Protocol，传输控制协议）: UDP( User Datagram Protocol 用户数据报协议)，在网络中它与TCP协议一样用于处理数据包。在OSI模型中，在第四层——传输层，处于IP协议的上一层。 IP协议: IP (Internet Protocol),处于网络层上(第三层) 网络层: 网络层负责对子网间的数据包进行路由选择。网络层还可以实现拥塞控制、网际互连等功能。 在这一层，数据的单位称为数据包（packet）。网络层协议的代表包括：IP、IPX、RIP、OSPF、ARP、RARP、ICMP、IGMP等。 传输层: 传输层是第一个端到端，即主机到主机的层次。传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输。此外，传输层还要处理端到端的差错控制和流量控制问题。 在这一层，数据的单位称为数据段（segment）。传输层协议的代表包括：TCP、UDP、SPX等。 应用层: 应用层为操作系统或网络应用程序提供访问网络服务的接口。应用层协议的代表包括：Telnet、FTP、HTTP、SNMP等。 ##什么是TCP和UDP ## TCP和UDP协议的区别(面试中经常问到): UDP 面向无连接，数据不安全，速度快。不区分客户端与服务端。 TCP * 面向连接（三次握手），数据安全，速度略低。分为客户端和服务端。 三次握手: 客户端先向服务端发起请求, 服务端响应请求, 传输数据 在这里在说说sockect(套接字) 网络上具有唯一标识的IP地址和端口号组合在一起才能构成唯一能识别的标识符套接字。 通信的两端都有Socket。 网络通信其实就是Socket间的通信。 数据在两个Socket间通过IO流传输。 Socket在应用程序中创建，通过一种绑定机制与驱动程序建立关系，告诉自己所对应的IP和port。 UDP传输DatagramSocket类用来创建和发送UDP的Socket实例; DatagramSocket()：创建实例。通常用于客户端编程，它并没有特定监听的端口，仅仅使用一个临时的。 DatagramSocket(int port)：创建实例，并固定监听Port端口的报文。 DatagramSocket(int port, InetAddress localAddr)：这是个非常有用的构建器，当一台机器拥有多于一个IP地址的时候，由它创建的实例仅仅接收来自LocalAddr的报文 receive(DatagramPacket d)：接收数据报文到d中。receive方法产生一个“阻塞”。 send(DatagramPacket d)：发送报文d到目的地。 setSoTimeout(int timeout)：设置超时时间，单位为毫秒。 close()：关闭DatagramSocket。在应用程序退出的时候，通常会主动释放资源，关闭Socket，但是由于异常地退出可能造成资源无法回收。所以，应该在程序完成时，主动使用此方法关闭Socket，或在捕获到异常抛出后关闭Sock DatagramPacket：用于处理报文，将byte数组、目标地址、目标端口等数据包装成报文或者将报文拆卸成byte数组。 DatagramPacket(byte[] buf, int length, InetAddress addr, int port)：从buf数组中，取出length长的数据创建数据包对象，目标是addr地址，port端口。 DatagramPacket(byte[] buf, int offset, int length, InetAddress address, int port)：从buf数组中，取出offset开始的、length长的数据创建数据包对象，目标是addr地址，port端口。 DatagramPacket(byte[] buf, int offset, int length)：将数据包中从offset开始、length长的数据装进buf数组。 DatagramPacket(byte[] buf, int length)：将数据包中length长的数据装进buf数组。 getData()：它从实例中取得报文的byte数组编码。 1.发送Send 创建DatagramSocket, 随机端口号 创建DatagramPacket, 指定数据, 长度, 地址, 端口 使用DatagramSocket发送DatagramPacket 关闭DatagramSocket 2.接收Receive 创建DatagramSocket, 指定端口号 创建DatagramPacket, 指定数组, 长度 使用DatagramSocket接收DatagramPacket 关闭DatagramSocket 从DatagramPacket中获取数据 3.接收方获取ip和端口号 String ip = packet.getAddress().getHostAddress(); int port = packet.getPort(); 发送端的java代码: package com.heima.socket; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetAddress; import java.net.SocketException; import java.net.UnknownHostException; public class Demo1_Send { /** * * 1.发送Send * 创建DatagramSocket, 随机端口号 * 创建DatagramPacket, 指定数据, 长度, 地址, 端口 * 使用DatagramSocket发送DatagramPacket * 关闭DatagramSocket * @throws SocketException * @throws UnknownHostException */ public static void main(String[] args) throws Exception { String str = &quot;what are you 弄啥呢?&quot;; DatagramSocket socket = new DatagramSocket(); //创建Socket相当于创建码头 //InetAddress.getByName(&quot;127.0.0.1&quot;):要发给谁,要写对方的ip地址 DatagramPacket packet = //创建Packet相当于集装箱,,存放要发送的数据 new DatagramPacket(str.getBytes(), str.getBytes().length, InetAddress.getByName(&quot;127.0.0.1&quot;), 6666); socket.send(packet); //发货,将数据发出去 socket.close(); //关闭码头 } } UDP传输的接收端: package com.heima.socket; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.SocketException; public class Demo1_Receive { /** ** 2.接收Receive * 创建DatagramSocket, 指定端口号 * 创建DatagramPacket, 指定数组, 长度 * 使用DatagramSocket接收DatagramPacket * 关闭DatagramSocket * 从DatagramPacket中获取数据 * @throws Exception */ public static void main(String[] args) throws Exception { DatagramSocket socket = new DatagramSocket(6666); //创建Socket相当于创建码头 DatagramPacket packet = new DatagramPacket(new byte[1024], 1024);//创建Packet相当于创建集装箱 socket.receive(packet); //接货,接收数据 byte[] arr = packet.getData(); //获取数据 int len = packet.getLength(); //获取有效的字节个数 System.out.println(new String(arr,0,len)); socket.close(); } } 对上面的代码进行优化: 发送端优化代码展示: package com.heima.socket; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetAddress; import java.net.SocketException; import java.net.UnknownHostException; import java.util.Scanner; public class Demo2_Send { /** * * 1.发送Send * 创建DatagramSocket, 随机端口号 * 创建DatagramPacket, 指定数据, 长度, 地址, 端口 * 使用DatagramSocket发送DatagramPacket * 关闭DatagramSocket * @throws SocketException * @throws UnknownHostException */ public static void main(String[] args) throws Exception { Scanner sc = new Scanner(System.in); //创建键盘录入对象 DatagramSocket socket = new DatagramSocket(); //创建Socket相当于创建码头 while(true) { String line = sc.nextLine(); //获取键盘录入的字符串 if(&quot;quit&quot;.equals(line)) { break; } DatagramPacket packet = //创建Packet相当于集装箱 new DatagramPacket(line.getBytes(), line.getBytes().length, InetAddress.getByName(&quot;127.0.0.1&quot;), 6666); socket.send(packet); //发货,将数据发出去 } socket.close(); //关闭码头 } } 接收端代码优化展示: package com.heima.socket; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.SocketException; public class Demo2_Receive { /** ** 2.接收Receive * 创建DatagramSocket, 指定端口号 * 创建DatagramPacket, 指定数组, 长度 * 使用DatagramSocket接收DatagramPacket * 关闭DatagramSocket * 从DatagramPacket中获取数据 * @throws Exception */ public static void main(String[] args) throws Exception { DatagramSocket socket = new DatagramSocket(6666); //创建Socket相当于创建码头 DatagramPacket packet = new DatagramPacket(new byte[1024], 1024);//创建Packet相当于创建集装箱 while(true) { socket.receive(packet); //接货,接收数据 byte[] arr = packet.getData(); //获取数据 int len = packet.getLength(); //获取有效的字节个数 String ip = packet.getAddress().getHostAddress(); //获取ip地址 int port = packet.getPort(); //获取端口号 System.out.println(ip + &quot;:&quot; + port + &quot;:&quot; + new String(arr,0,len)); } } }]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Esp8266无线配对源码分析]]></title>
    <url>%2F2018%2F01%2F10%2Ffrist%2F</url>
    <content type="text"><![CDATA[执行一任务中Activity的解析告诉自己每天认真的学习,充电!过好每一天. 我们执行异步任务的类是: EsptouchDemoActivity new EsptouchAsyncTask3().execute(apSsid, apBssid, apPassword, isSsidHiddenStr, taskResultCountStr); // 参数 apssid apbssid appassword no 1; 开始分析这个异步任务参数说明,是哪个参数分别是在doInBackground中使用到的, 和设置进度条使用到的, 最后是在onPostExecuter中使用到的,是一个集合; 我们看看这个接口 : IEsptouchResult 里面有四个方法:第一个方法是 是否继续进行下一步 第二个方法是检查这个任务是不是用户自己关闭的; 第三个方法是: 获取设备的bssid 第四个方法是获取设备的 ip地址. private class EsptouchAsyncTask3 extends AsyncTask&lt;String, Void, List&lt;IEsptouchResult&gt;&gt; { private ProgressDialog mProgressDialog; private IEsptouchTask mEsptouchTask; private final Object mLock = new Object(); @Override protected void onPreExecute() { // 准备工作 异步任务的第一个方法,其实就是展示对话框,直接不看,有一点就是有队task的是不是空的判断,非空直接打断 } @Override // 异步任务的最后返回的结果 没什么可看的,最重要的在上面 protected void onPostExecute(List&lt;IEsptouchResult&gt; result) { IEsptouchResult firstResult = result.get(0); Log.d(TAG, &quot;onPostExecute: &quot;); if (!firstResult.isCancelled()) {// isCancelled 表示是不是客户关闭的 这里不是客户关闭的 // int count = 0; // final int maxDisplayCount = 5; if (firstResult.isSuc()) { try { if(str_ssid_FLAG.equals(str_ssid)){ // if(!str_pass_FLAG.equals(str_pass)){ // dubug不走 if(str_ssid.length()&gt;0 &amp;&amp; str_pass.length()&gt;0 &amp;&amp; index!=-1){ ssid_list.set(index, str_ssid); pass_list.set(index, str_pass); writeSSID(FAVOSSIDPATH); writePASS(FAVOPASSPATH); } } }else{ if(str_ssid.length()&gt;0 &amp;&amp; str_pass.length()&gt;0){ ssid_list.add(str_ssid); pass_list.add(str_pass); writeSSID(FAVOSSIDPATH); writePASS(FAVOPASSPATH); } } } catch (Exception e) { // TODO Auto-generated catch block e.printStackTrace(); } new AlertDialog.Builder(EsptouchDemoActivity.this) .setIcon(android.R.drawable.ic_dialog_info) .setTitle(&quot;提示&quot;) .setMessage(&quot;配置成功!&quot;) .setPositiveButton(&quot;确定&quot;, new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int whichButton) { dialog.dismiss(); finish(); } }).show(); } else { str_ssid = null; str_pass = null; new AlertDialog.Builder(EsptouchDemoActivity.this) .setIcon(android.R.drawable.ic_dialog_info) .setTitle(&quot;提示&quot;) .setMessage(&quot;配置失败，请重试!&quot;) .setPositiveButton(&quot;确定&quot;, new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int whichButton) { dialog.dismiss(); } }).show(); } } } } 上面的是准备的方法和最后的返回的方法; 我们单独将 doInBackground 分出来设置一下子 @Override // 关键方法 protected List&lt;IEsptouchResult&gt; doInBackground(String... params) { int taskResultCount = -1; // 初始化默认的值 最后赋值为1 synchronized (mLock) { // 获取传递过来的参数 String apSsid = params[0]; // ssid String apBssid = params[1]; // bssid String apPassword = params[2]; // 密码 String isSsidHiddenStr = params[3]; // no String taskResultCountStr = params[4]; // 1 boolean isSsidHidden = false; if (isSsidHiddenStr.equals(&quot;YES&quot;)) { // 不会执行 isSsidHidden = true; } taskResultCount = Integer.parseInt(taskResultCountStr); //1 实质就是讲转化的string 转化为int 结果就是我们选择的1 mEsptouchTask = new EsptouchTask(apSsid, apBssid, apPassword, //传递参数 isSsidHidden, EsptouchDemoActivity.this); mEsptouchTask.setEsptouchListener(myListener); // 这是参数类型 IEsptouchListener 这个接口里面只有一个方法就是添加 IEsptouchResult的方法; } List&lt;IEsptouchResult&gt; resultList = mEsptouchTask.executeForResults(taskResultCount); // return resultList; } 我们看到首先是将参数传递到EsptouchTask中: public EsptouchTask(String apSsid, String apBssid, String apPassword, boolean isSsidHidden, Context context) { _mParameter = new EsptouchTaskParameter(); _mEsptouchTask = new __EsptouchTask(apSsid, apBssid, apPassword, context, _mParameter, isSsidHidden); } EsptouchTaskParameter我们看过,里面定义了很多的常量和方法,不细看了再一次将参数传递过去__EsptouchTask: public __EsptouchTask(String apSsid, String apBssid, String apPassword, Context context, IEsptouchTaskParameter parameter, boolean isSsidHidden) { // 空处理不看了 接下来就是成员变量接收传递过来的信息 mContext = context; mApSsid = apSsid; mApBssid = apBssid; mApPassword = apPassword; mIsCancelled = new AtomicBoolean(false); // 多线程高并发使用的饿一个类 比较和赋值一体化 mSocketClient = new UDPSocketClient(); // 具有发送 DatagramPacket的方法 mParameter = parameter; // 获取定义好的数据类型的值 mSocketServer = new UDPSocketServer(mParameter.getPortListening(), // 获取端口监听 超时时间 上下文 mParameter.getWaitUdpTotalMillisecond(), context); mIsSsidHidden = isSsidHidden; // false mEsptouchResultList = new ArrayList&lt;IEsptouchResult&gt;(); // 创建一个存放IEsptouchResult的集合 mBssidTaskSucCountMap = new HashMap&lt;String, Integer&gt;(); // 创建集合 来干嘛的 关于ssid的task 进行数量的一个集合 } 我们继续查看: new AtomicBoolean(false); 传递的是一个false 实际测试的结果也是false;接下来是一个实例化了一 UDPSocketClient 我们看看坐的是什么操作: public UDPSocketClient() { try { this.mSocket = new DatagramSocket(); // 用于接收的发送udp的sockect的实例 this.mIsStop = false; this.mIsClosed = false; } catch (SocketException e) { if (__IEsptouchTask.DEBUG) { // 日志管理 是true Log.e(TAG, &quot;SocketException&quot;); } e.printStackTrace(); } } 我们可以看出来,在实际的过程中,创建udp通信实例中,初始化了数据包.我们继续,获取的参数parameter,以成员变量保存,下面一个是我们看到udpsockectServer ,将获取到的监听端口传递进去; 监听端口是18266 设置超时的时间是60000 ,一个上下文 关于UDPSocketServer代码如下: public UDPSocketServer(int port, int socketTimeout, Context context) { // 第一个是我们需要监听的端口 18266, 超时时间, 山下文 this.mContext = context; this.buffer = new byte[64]; this.mReceivePacket = new DatagramPacket(buffer, 64); // 接收DatagramSockect try { this.mServerSocket = new DatagramSocket(port); this.mServerSocket.setSoTimeout(socketTimeout); this.mIsClosed = false; // 获取Android的wifi管理 WifiManager manager = (WifiManager) mContext .getSystemService(Context.WIFI_SERVICE); mLock = manager.createMulticastLock(&quot;test wifi&quot;); // 创建组播锁 输入的&quot;test wifi 是一个tag&quot; 最后会调用acquire Log.d(TAG, &quot;mServerSocket is created, socket read timeout: &quot; + socketTimeout + &quot;, port: &quot; + port); } catch (IOException e) { Log.e(TAG, &quot;IOException&quot;); e.printStackTrace(); } } 我们在doInbackground中看到传递一个myListener,我们看看最后传递到哪里了!参数的类型如下: // myListener的类型是一个接口: 接口IEsptouchListener 只有一个方法那就是 添加onEsptouchResultAdded()方法;添加的参数类型IEsptouchResul(四个方法是关于设备的,监听回调) 第一将这个监听回调对象传递到 EsptouchTsak类中: 具体代码如下: @Override public void setEsptouchListener(IEsptouchListener esptouchListener) { _mEsptouchTask.setEsptouchListener(esptouchListener); } 我们可以看到类型不变,只不过传递到_mEsptouchTask,我们继续查看: _mEsptouchTask类中: @Override public void setEsptouchListener(IEsptouchListener esptouchListener) { mEsptouchListener = esptouchListener; } 最后也就是在_mEsptouchTask类中接收了, 成员变量来保存. 最后我们看看 关键方法List&lt;IEsptouchResult&gt; resultList = mEsptouchTask.executeForResults(taskResultCount); //默认是1,可以在下拉刷新中选择 继续在EsptouchTask中查找这个方法 public List&lt;IEsptouchResult&gt; executeForResults(int expectTaskResultCount) //传递过来是1 默认是1可以选择 throws RuntimeException { if (expectTaskResultCount &lt;= 0) { expectTaskResultCount = Integer.MAX_VALUE; } return _mEsptouchTask.executeForResults(expectTaskResultCount); // 再次传递执行 } 同理也就是传递到 _mEsptouchTask中去,我们继续查看 /** * 4 追查的结果 _mEsptouchTask.executeForResults(expectTaskResultCount); // 传递的是1 * // 关键方法 @Override public List&lt;IEsptouchResult&gt; executeForResults(int expectTaskResultCount)throws RuntimeException { __checkTaskValid(); // 判断esptouchtask只能执行一次 不需要看 mParameter.setExpectTaskResultCount(expectTaskResultCount); // udp 通信中获取 up地址 ESPnETTYIL工具类 InetAddress localInetAddress = EspNetUtil.getLocalInetAddress(mContext); // 结果是获取手机的IP地址 192.168.188.23 // generator the esptouch byte[][] to be transformed, which will cost // some time(maybe a bit much) IEsptouchGenerator generator = new EsptouchGenerator(mApSsid, mApBssid, mApPassword, localInetAddress, mIsSsidHidden); // listen the esptouch result asyn __listenAsyn(mParameter.getEsptouchResultTotalLen()); 实质就是 _listenAsyn(11); boolean isSuc = false; for (int i = 0; i &lt; mParameter.getTotalRepeatTime(); i++) { //mParameter.getTotalRepeatTime()=1; isSuc = __execute(generator); // 这个方法中会去发送数据包 if (isSuc) { return __getEsptouchResultList(); } } if (!mIsInterrupt) { // wait the udp response without sending udp broadcast try { Thread.sleep(mParameter.getWaitUdpReceivingMillisecond()); } catch (InterruptedException e) { // receive the udp broadcast or the user interrupt the task if (this.mIsSuc) { return __getEsptouchResultList(); } else { this.__interrupt(); return __getEsptouchResultList(); } } this.__interrupt(); } return __getEsptouchResultList(); } */ 我们首先看第一个关键性的方法有一个小的操作需要看看 mParameter.setExpectTaskResultCount(expectTaskResultCount); @Override public int getExpectTaskResultCount() { return this.mExpectTaskResultCount; } @Override public void setExpectTaskResultCount(int expectTaskResultCount) { this.mExpectTaskResultCount = expectTaskResultCount; } 我们看看又初始化了一个类:localInetAddress这个是获取手机的IP地址 这里就是192.168.188.23 IEsptouchGenerator generator = new EsptouchGenerator(mApSsid, mApBssid, mApPassword, localInetAddress, mIsSsidHidden); 我们看看初始化的时候的操作: public EsptouchGenerator(String apSsid, String apBssid, String apPassword, InetAddress inetAddress, boolean isSsidHiden) { // ssid bssid pwd 192.168.188.23, false // generate guide code GuideCode gc = new GuideCode(); char[] gcU81 = gc.getU8s(); mGcBytes2 = new byte[gcU81.length][]; for (int i = 0; i &lt; mGcBytes2.length; i++) { mGcBytes2[i] = ByteUtil.genSpecBytes(gcU81[i]); //看看这个数据装的是什么 } // generate data code DatumCode dc = new DatumCode(apSsid, apBssid, apPassword, inetAddress, isSsidHiden); char[] dcU81 = dc.getU8s(); mDcBytes2 = new byte[dcU81.length][]; for (int i = 0; i &lt; mDcBytes2.length; i++) { mDcBytes2[i] = ByteUtil.genSpecBytes(dcU81[i]); //看看这个数据装的是什么 } } 我们debug打印一下子就OK了! gcU81:四个元素: mGcBytes2: DatumCode: mDcBytes2: 直接图片展示: 下面的都是关于 DatumCode的构造方法: public DatumCode(String apSsid, String apBssid, String apPassword, InetAddress ipAddress, boolean isSsidHiden) { // 构造方法 // Data = total len(1 byte) + apPwd len(1 byte) + SSID CRC(1 byte) + // BSSID CRC(1 byte) + TOTAL XOR(1 byte)+ ipAddress(4 byte) + apPwd + apSsid apPwdLen &lt;= // 105 at the moment // total xor char totalXor = 0; char apPwdLen = (char) ByteUtil.getBytesByString(apPassword).length; CRC8 crc = new CRC8(); crc.update(ByteUtil.getBytesByString(apSsid)); char apSsidCrc = (char) crc.getValue(); crc.reset(); crc.update(EspNetUtil.parseBssid2bytes(apBssid)); char apBssidCrc = (char) crc.getValue(); char apSsidLen = (char) ByteUtil.getBytesByString(apSsid).length; // hostname parse String ipAddrStrs[] = ipAddress.getHostAddress().split(&quot;\\.&quot;); int ipLen = ipAddrStrs.length; char ipAddrChars[] = new char[ipLen]; // only support ipv4 at the moment for (int i = 0; i &lt; ipLen; ++i) { ipAddrChars[i] = (char) Integer.parseInt(ipAddrStrs[i]); } char _totalLen = (char) (EXTRA_HEAD_LEN + ipLen + apPwdLen + apSsidLen); char totalLen = isSsidHiden ? (char) (EXTRA_HEAD_LEN + ipLen + apPwdLen + apSsidLen) : (char) (EXTRA_HEAD_LEN + ipLen + apPwdLen); // build data codes mDataCodes = new DataCode[totalLen]; mDataCodes[0] = new DataCode(_totalLen, 0); totalXor ^= _totalLen; mDataCodes[1] = new DataCode(apPwdLen, 1); totalXor ^= apPwdLen; mDataCodes[2] = new DataCode(apSsidCrc, 2); totalXor ^= apSsidCrc; mDataCodes[3] = new DataCode(apBssidCrc, 3); totalXor ^= apBssidCrc; mDataCodes[4] = null; for (int i = 0; i &lt; ipLen; ++i) { mDataCodes[i + EXTRA_HEAD_LEN] = new DataCode(ipAddrChars[i], i + EXTRA_HEAD_LEN); totalXor ^= ipAddrChars[i]; } byte[] apPwdBytes = ByteUtil.getBytesByString(apPassword); char[] apPwdChars = new char[apPwdBytes.length]; for (int i = 0;i &lt; apPwdBytes.length; i++) { apPwdChars[i] = ByteUtil.convertByte2Uint8(apPwdBytes[i]); } for (int i = 0; i &lt; apPwdChars.length; i++) { mDataCodes[i + EXTRA_HEAD_LEN + ipLen] = new DataCode( apPwdChars[i], i + EXTRA_HEAD_LEN + ipLen); totalXor ^= apPwdChars[i]; } byte[] apSsidBytes = ByteUtil.getBytesByString(apSsid); char[] apSsidChars = new char[apSsidBytes.length]; // totalXor will xor apSsidChars no matter whether the ssid is hidden for (int i = 0; i &lt; apSsidBytes.length; i++) { apSsidChars[i] = ByteUtil.convertByte2Uint8(apSsidBytes[i]); totalXor ^= apSsidChars[i]; } if (isSsidHiden) { for (int i = 0; i &lt; apSsidChars.length; i++) { mDataCodes[i + EXTRA_HEAD_LEN + ipLen + apPwdLen] = new DataCode( apSsidChars[i], i + EXTRA_HEAD_LEN + ipLen + apPwdLen); } } // set total xor last mDataCodes[4] = new DataCode(totalXor, 4); } 下面的是一个关键性方法__listenAsyn(mParameter.getEsptouchResultTotalLen());listenAsyn(mParameter.getEsptouchResultTotalLen());实质就是listenAsyn(11); private void __listenAsyn(final int expectDataLen) { //11 new Thread() { public void run() { long startTimestamp = System.currentTimeMillis();//获取系统当前时间 byte[] apSsidAndPassword = ByteUtil.getBytesByString(mApSsid + mApPassword); //return string.getBytes(ESPTOUCH_ENCODING_CHARSET); 转化为utf-8的格式 byte expectOneByte = (byte) (apSsidAndPassword.length + 9); // 看一下子期望的字节 byte receiveOneByte = -1; // 接收的字节 byte[] receiveBytes = null; // 接收的字节数组 while (mEsptouchResultList.size() &lt; mParameter .getExpectTaskResultCount() &amp;&amp; !mIsInterrupt) { receiveBytes = mSocketServer .receiveSpecLenBytes(expectDataLen); // 接收特定的特殊的字符 11 if (receiveBytes != null) { receiveOneByte = receiveBytes[0]; } else { receiveOneByte = -1; } // 接收到的字节和期望的字节一致 if (receiveOneByte == expectOneByte) { if (__IEsptouchTask.DEBUG) { Log.i(TAG, &quot;receive correct broadcast&quot;); } // change the socket&apos;s timeout long consume = System.currentTimeMillis() - startTimestamp; // 当前的异步的时间减去开始异步监听的系统时间 int timeout = (int) (mParameter .getWaitUdpTotalMillisecond() - consume); // 60000-consume if (timeout &lt; 0) { // 超时 if (__IEsptouchTask.DEBUG) { Log.i(TAG, &quot;esptouch timeout&quot;); } break; } else { // 没有超时 if (__IEsptouchTask.DEBUG) { Log.i(TAG, &quot;mSocketServer&apos;s new timeout is &quot; + timeout + &quot; milliseconds&quot;); } mSocketServer.setSoTimeout(timeout); if (__IEsptouchTask.DEBUG) { Log.i(TAG, &quot;receive correct broadcast&quot;); } if (receiveBytes != null) { String bssid = ByteUtil.parseBssid( // 解析获取的设备ssid receiveBytes, mParameter.getEsptouchResultOneLen(), // 查询是1 mParameter.getEsptouchResultMacLen()); //查询是6 InetAddress inetAddress = EspNetUtil // 解析获取的设备的 ip地址 .parseInetAddr( receiveBytes, mParameter.getEsptouchResultOneLen() //1 + mParameter.getEsptouchResultMacLen(), //6 mParameter.getEsptouchResultIpLen());//4 __putEsptouchResult(true, bssid, inetAddress); // 存放到集合 } } } else { if (__IEsptouchTask.DEBUG) { Log.i(TAG, &quot;receive rubbish message, just ignore&quot;); } } } mIsSuc = mEsptouchResultList.size() &gt;= mParameter .getExpectTaskResultCount(); // size和1比较 __EsptouchTask.this.__interrupt();// 打断 if (__IEsptouchTask.DEBUG) { Log.d(TAG, &quot;__listenAsyn() finish&quot;); } } }.start(); } 首先是这个方法里面又开了一个子线程来运行程序:其他的都直接在程序中说明: 我们看看存放的方法 __putEsptouchResult(): private void __putEsptouchResult(boolean isSuc, String bssid, InetAddress inetAddress) { synchronized (mEsptouchResultList) { // check whether the result receive enough UDP response boolean isTaskSucCountEnough = false; Integer count = mBssidTaskSucCountMap.get(bssid);// map结合根据bssid获取 count if (count == null) { count = 0; } ++count; if (__IEsptouchTask.DEBUG) { Log.d(TAG, &quot;__putEsptouchResult(): count = &quot; + count); } mBssidTaskSucCountMap.put(bssid, count); // 存放到集合中 isTaskSucCountEnough = count &gt;= mParameter .getThresholdSucBroadcastCount(); // 将count和1比较 if (!isTaskSucCountEnough) { if (__IEsptouchTask.DEBUG) { Log.d(TAG, &quot;__putEsptouchResult(): count = &quot; + count + &quot;, isn&apos;t enough&quot;); } return; } // check whether the result is in the mEsptouchResultList already 检查是否存在 boolean isExist = false; for (IEsptouchResult esptouchResultInList : mEsptouchResultList) { if (esptouchResultInList.getBssid().equals(bssid)) { isExist = true; break; } } // only add the result who isn&apos;t in the mEsptouchResultList if (!isExist) { // 不存在,new一个 EsptouchResult并进行复制,走到这一步就是成功的,后面有失败的处理,失败集合就是null的. if (__IEsptouchTask.DEBUG) { Log.d(TAG, &quot;__putEsptouchResult(): put one more result&quot;); } final IEsptouchResult esptouchResult = new EsptouchResult(isSuc, bssid, inetAddress); mEsptouchResultList.add(esptouchResult); if (mEsptouchListener != null) { mEsptouchListener.onEsptouchResultAdded(esptouchResult); } } } } 我们看完继续看:__execute(generator); isSuc = __execute(generator); // 这个方法中会去发送数据包 private boolean __execute(IEsptouchGenerator generator) { long startTime = System.currentTimeMillis(); long currentTime = startTime; long lastTime = currentTime - mParameter.getTimeoutTotalCodeMillisecond();// 6000 (不是60000) byte[][] gcBytes2 = generator.getGCBytes2(); byte[][] dcBytes2 = generator.getDCBytes2(); int index = 0; while (!mIsInterrupt) { if (currentTime - lastTime &gt;= mParameter.getTimeoutTotalCodeMillisecond()) { // 6000 if (__IEsptouchTask.DEBUG) { Log.d(TAG, &quot;send gc code &quot;); } // send guide code while (!mIsInterrupt &amp;&amp; System.currentTimeMillis() - currentTime &lt; mParameter .getTimeoutGuideCodeMillisecond()) { //6000 // 也是一个发送数据的地方 mSocketClient.sendData(gcBytes2, mParameter.getTargetHostname(), mParameter.getTargetPort(), mParameter.getIntervalGuideCodeMillisecond()); // check whether the udp is send enough time if (System.currentTimeMillis() - startTime &gt; mParameter.getWaitUdpSendingMillisecond()) { break; } } lastTime = currentTime; } else { // 发送数据报文 mSocketClient.sendData(dcBytes2, index, ONE_DATA_LEN, mParameter.getTargetHostname(), //234.1.1.1, 234.2.2.2, 234.3.3.3 to 234.100.100.100 mParameter.getTargetPort(), //7001 mParameter.getIntervalDataCodeMillisecond()); // 10 index = (index + ONE_DATA_LEN) % dcBytes2.length; // (index+3)%dcBytes2.length; } currentTime = System.currentTimeMillis(); // check whether the udp is send enough time if (currentTime - startTime &gt; mParameter.getWaitUdpSendingMillisecond()) { break; } } return mIsSuc; } 我们来看看具体的发送的发送的hostname: // target hostname is : 234.1.1.1, 234.2.2.2, 234.3.3.3 to 234.100.100.100 @Override public String getTargetHostname() { int count = __getNextDatagramCount(); return &quot;234.&quot; + count + &quot;.&quot; + count + &quot;.&quot; + count; } 还差最后一点方法:executeForResults(1) if (isSuc) { return __getEsptouchResultList(); } 上面返回的 isSUC的值为true 获取__getEsptouchResultList(); private List&lt;IEsptouchResult&gt; __getEsptouchResultList() { synchronized (mEsptouchResultList) { if (mEsptouchResultList.isEmpty()) { // 失败的结果,也返回这不过返回的就是 false 和null null EsptouchResult esptouchResultFail = new EsptouchResult(false, null, null); esptouchResultFail.setIsCancelled(mIsCancelled.get()); mEsptouchResultList.add(esptouchResultFail); } return mEsptouchResultList; } } 整体的过程结束.我们查看查看,发送数据那一段: IEsptouchGenerator generator = new EsptouchGenerator(mApSsid, mApBssid, mApPassword, localInetAddress, mIsSsidHidden);开始说起: public EsptouchGenerator(String apSsid, String apBssid, String apPassword, InetAddress inetAddress, boolean isSsidHiden) { // generate guide code GuideCode gc = new GuideCode(); char[] gcU81 = gc.getU8s();// 获取的就是 515 514 5123 512 mGcBytes2 = new byte[gcU81.length][];// 创建数组 for (int i = 0; i &lt; mGcBytes2.length; i++) { mGcBytes2[i] = ByteUtil.genSpecBytes(gcU81[i]); } // generate data code DatumCode dc = new DatumCode(apSsid, apBssid, apPassword, inetAddress, isSsidHiden); char[] dcU81 = dc.getU8s(); mDcBytes2 = new byte[dcU81.length][]; for (int i = 0; i &lt; mDcBytes2.length; i++) { mDcBytes2[i] = ByteUtil.genSpecBytes(dcU81[i]); // 注意的是 图片显示的是0123 ,表示的是下表,是一个二维数组 } } 我们再来看看:GuideCode 源代码如下: public class GuideCode implements ICodeData { public static final int GUIDE_CODE_LEN = 4; @Override public byte[] getBytes() { throw new RuntimeException(&quot;DataCode don&apos;t support getBytes()&quot;); } @Override public String toString() { StringBuilder sb = new StringBuilder(); char[] dataU8s = getU8s(); for (int i = 0; i &lt; GUIDE_CODE_LEN; i++) { String hexString = ByteUtil.convertU8ToHexString(dataU8s[i]); sb.append(&quot;0x&quot;); if (hexString.length() == 1) { sb.append(&quot;0&quot;); } sb.append(hexString).append(&quot; &quot;); } return sb.toString(); } @Override public char[] getU8s() { char[] guidesU8s = new char[GUIDE_CODE_LEN]; guidesU8s[0] = 515; guidesU8s[1] = 514; guidesU8s[2] = 513; guidesU8s[3] = 512; return guidesU8s; } } 解释如下: 实现的接口代码: byte[] getBytes(); //Get the byte[] to be transformed. char[] getU8s(); //Get the char[](u8[]) to be transfromed. 我们看看实现的过程,字节直接是一个空方法,下面看getU8s()数组中分别开始赋值 515到512,tostring()的操作: 最后的结果如下: // dubug的测试的最后结果是: 0x203 0x202 0x201 0x200 注意前面的ox是直接添加的 我们继续看DatumCode类: 就这样吧!]]></content>
  </entry>
  <entry>
    <title><![CDATA[this is new page hello world]]></title>
    <url>%2F2018%2F01%2F08%2Fthis-is-new-page-hello-world%2F</url>
    <content type="text"><![CDATA[我们实际测试的页面开启评论的设置,于七分是自己的一个idea,曾经在回想着全身心的付出就是对你最好的回应,抛掉过往,和那些我所不能偿还的人们说清楚,认真二字我估计是他们对我信心的认可,只是于七分,太满会溢出.于七分,三分给自己,自爱(爱护身体),自息(天行健君子以自强不息,地势坤君子以厚德载物),自强(提高自己,不断的学习),坚持(毅力和执行力). comments 设置为true 就可以了! 设置阅读更多的操作: 方式有三种: 第一种是使用 之歌标志之前的会作为简介来展现,出现点击阅读全文的字样. 在文章的 front-matter 中添加description,,,,,,具体的格式是如下: description: 这是我要展示的简介文字 第三个就是 配置主题文件的配置文件 auto_excerpt” enable: true length: 150(表示截取的长度是150字符,也是默认的)]]></content>
      <tags>
        <tag>博客</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
