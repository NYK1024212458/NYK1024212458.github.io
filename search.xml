<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[BottomNavigationView实现底部导航栏的实现]]></title>
      <url>/2018/02/08/BottomNavigationView%E5%AE%9E%E7%8E%B0%E5%BA%95%E9%83%A8%E5%AF%BC%E8%88%AA%E6%A0%8F%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[升级apk和更新安装apk的整理]]></title>
      <url>/2018/01/31/%E5%8D%87%E7%BA%A7apk%E5%92%8C%E6%9B%B4%E6%96%B0%E5%AE%89%E8%A3%85apk%E7%9A%84%E6%95%B4%E7%90%86/</url>
      <content type="html"><![CDATA[<p> 本片是对于安装更新apk的一个集成功能的总结和流程和总结,便于后期遇到,直接复制粘贴使用,需要的文件全部都有,按照自己的思路来总结的,比较详细,也比较多余,权当做是一个笔记来对待就行.<a id="more"></a></p>
<p>#延迟展示对话框 #</p>
<pre><code>private void initView() {

    ....

    //r:消息的执行操作
    //delayMillis : 延迟时间,但是毫秒值
    new Handler().postDelayed(new Runnable() {

        @Override
        public void run() {
            //提醒用户更新版本
            update();
        }
    }, 2000);//延迟多少时间给handler发送消息

    //delayMillis : 延迟时间,单位毫秒值
    /*new Handler(){
        public void handleMessage(android.os.Message msg) {
            //提醒用户更新版本
            update();
        };
    }.sendEmptyMessageDelayed(0, 2000);*///延迟多长时间给handler发送消息

}
</code></pre><hr>
<h1 id="自己学习和总结的关于app的升级和安装"><a href="#自己学习和总结的关于app的升级和安装" class="headerlink" title="自己学习和总结的关于app的升级和安装"></a>自己学习和总结的关于app的升级和安装</h1><p>就是我们在splash页面(自己随意)先获取自己的版本VersionCode我们在获取服务端的一个json,获取里面的serverVersionCode,比较这两个值,ServerVersionCode &gt; versionCode 进行弹出对话框提示跟新,否则继续执行动画.点击下次在说继续执行动画,点击现在下载,进行下载,之后下载安转. 下载使用的是系统的DownloadManager,下载完成后发送广播,我们需要先注册一个广播</p>
<h2 id="关于VersionCode和VersionName的区别"><a href="#关于VersionCode和VersionName的区别" class="headerlink" title="关于VersionCode和VersionName的区别"></a>关于VersionCode和VersionName的区别</h2><p>首先就引用一下子: </p>
<pre><code>Google为APK定义了两个关于版本属性：VersionCode和VersionName，他们有不同的用途。
VersionCode：对消费者不可见，仅用于应用市场、程序内部识别版本，判断新旧等用途。
VersionName：展示给消费者，消费者会通过它认知自己安装的版本
</code></pre><p>ok自己总结一下:</p>
<p>第一点就是: versioncode是用于版本更新和应用市场来判断是否提醒用户进行安装的一个标识. 而versionName是我们在安转软件的时候展示给用户观看的自己的安装的版本.</p>
<p>第二点是: verSionCode比较正式,而VersionName就比较随意了,可以随意的取名称.</p>
<h2 id="获取app的versionCode和versionName"><a href="#获取app的versionCode和versionName" class="headerlink" title="获取app的versionCode和versionName"></a>获取app的versionCode和versionName</h2><p>直接上源码:</p>
<pre><code>public class PackageUtils {
public static String getVersionName(Context mContext){
    // 获取package管理者  需要上下文
    PackageManager packageManager = mContext.getPackageManager();
    //参数说明   参数一是获取哪一个包名的package的信息 (application包括了activity所以也会包括activity的信息)
    //参数二的信息就是设置是不是之后去
    //获取包名的方法
    String packageName = mContext.getPackageName();

    try {
        PackageInfo packageInfo = packageManager.getPackageInfo(packageName, 0);
        //获取里面的信息
        String versionName = packageInfo.versionName;
        return  versionName;
    } catch (PackageManager.NameNotFoundException e) {
        e.printStackTrace();
    }
    // 获取里面的信息
    // applicationInfo.

    return  null;

}
// 获取版本信息
public static int  getVersionCode(Context mContext){
    // 获取package管理者  需要上下文
    PackageManager packageManager = mContext.getPackageManager();
    //参数说明   参数一是获取哪一个包名的package的信息 (application包括了activity所以也会包括activity的信息)
    //参数二的信息就是设置是不是获取其他的权限还是获取广播,设置为0只是获取简单的版本名称和版本信息
    //获取包名的方法
    String packageName = mContext.getPackageName();

    try {
        PackageInfo packageInfo = packageManager.getPackageInfo(packageName, 0);
        //获取里面的信息
        int versionCode = packageInfo.versionCode;
        return  versionCode;
    } catch (PackageManager.NameNotFoundException e) {
        e.printStackTrace();
    }


    return  -1;

}
}
</code></pre><h2 id="服务端的获取的信息"><a href="#服务端的获取的信息" class="headerlink" title="服务端的获取的信息"></a>服务端的获取的信息</h2><p>我访问服务端去获取服务端上app的VersionCode:</p>
<p>获取的json的展示: </p>
<pre><code>{
&quot;data&quot;: {
&quot;ServerVersionCode&quot;: &quot;2&quot;,
&quot;ServerVersionName&quot;: &quot;1.0.2&quot;,
&quot;appname&quot;: &quot;fabei.apk&quot;,
&quot;updateurl&quot;: &quot;http://IP地址/apk/fabei.apk&quot;,
&quot;upgradeinfo&quot;: &quot;V1.0.2版本更新，你想不想要试一下哈！！！&quot;
},
&quot;code&quot;: &quot;200&quot;,
&quot;code_msg&quot;: &quot;获取成功&quot;
}
</code></pre><p>我们可以看到下载地址.</p>
<h2 id="关于Retrofit的集成"><a href="#关于Retrofit的集成" class="headerlink" title="关于Retrofit的集成"></a>关于Retrofit的集成</h2><p>注意gradle中的添加的依赖: </p>
<pre><code> //网络请求框架
compile &apos;com.squareup.retrofit2:retrofit:2.3.0&apos;
compile &apos;com.squareup.retrofit2:converter-scalars:2.3.0&apos;
compile &apos;com.squareup.retrofit2:converter-gson:2.3.0&apos;
compile &apos;com.squareup.retrofit2:adapter-rxjava2:2.3.0&apos;

//RxJava框架
compile &apos;io.reactivex.rxjava2:rxandroid:2.0.1&apos;
compile &apos;io.reactivex.rxjava2:rxjava:2.1.5&apos;

 //运行时权限
compile &apos;com.tbruyelle.rxpermissions2:rxpermissions:0.9.1@aar&apos;  // 后面说到这个库
</code></pre><p>使用一个管理类:</p>
<pre><code>public class RetrofitManager {
private static RetrofitManager mRetrofitManager;
private static Retrofit mRetrofit;
private static Retrofit mDRetrofit;

private RetrofitManager() {

}

/**
 * 创建网络请求
 *
 * @param reqServer 网络接口
 * @param &lt;T&gt;       泛型
 * @return 返回网络接口对应的请求类
 */
private  &lt;T&gt; T createReq(Class&lt;T&gt; reqServer) {
    return mRetrofit.create(reqServer);
}
/**
 * 获取服务器网络请求接口对应的类
 *
 * @return 服务器网络请求接口对应的类
 */
public ServerApi getServer() {
    return createReq(ServerApi.class);
}

/**
 * 返回线程安全的单例
 *
 * @return RetrofitManager单例
 */
public static synchronized RetrofitManager getInstance() {
    if (mRetrofitManager == null) {
        mRetrofitManager = new RetrofitManager();
    }
    return mRetrofitManager;
}

//在自定义Application中初始化
public static void init() {
    OkHttpClient.Builder builder = new OkHttpClient.Builder();
    builder.connectTimeout(50, TimeUnit.SECONDS);
    builder.readTimeout(50, TimeUnit.SECONDS);
    builder.writeTimeout(50, TimeUnit.SECONDS);
    builder.retryOnConnectionFailure(true);
    OkHttpClient client = builder.build();

    mRetrofit = new Retrofit.Builder()
            .baseUrl(UrlConstant.BASE_URL)
            .addConverterFactory(ScalarsConverterFactory.create())
            .addConverterFactory(GsonConverterFactory.create())
            .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) //通过RxJavaCallAdapterFactory为Retrofit添加RxJava支持：
            .client(client)
            .build();
}
}
</code></pre><p>贴一个ServerApi.class 的接口类:</p>
<pre><code>public interface ServerApi {
//其他的代码

 /**
 * 获取跟新app服务器信息
 * @return
 */

@GET(&quot;apk/upgrade.json&quot;)  // 这里面就是去掉主机host的其他路劲
Observable&lt;UpdateAppInfo&gt; getUpdateVersion ();

}
</code></pre><p>贴一个接口类: UrlConstant:</p>
<pre><code>public interface UrlConstant {
//服务器地址
public static final String BASE_URL = &quot;主机ip地址&quot;;
//本机地址
//public static final String BASE_URL = &quot;http://192.168.0.121:8080&quot;;
}
</code></pre><h2 id="splash界面代码书写"><a href="#splash界面代码书写" class="headerlink" title="splash界面代码书写"></a>splash界面代码书写</h2><p>splash的初始化界面:</p>
<p>便于接收到下载完成的通知,我们先初始化广播;在检查更新</p>
<pre><code>initUpdata();

   // 是否具有新版本

   checkUpdate();
</code></pre><p>具体的方法代码:</p>
<pre><code>/**
 * 初始化app更新广播
 */
private void initUpdata() {
    IntentFilter filter = new IntentFilter();
    filter.addAction(DownloadManager.ACTION_DOWNLOAD_COMPLETE);
    filter.addAction(DownloadManager.ACTION_NOTIFICATION_CLICKED);
    filter.addCategory(&quot;android.intent.category.DEFAULT&quot;);
    receiver = new DownLoadCompleteReceiver();
    registerReceiver(receiver, filter);
}
</code></pre><p>实质就是动态注册广播,action如下:</p>
<pre><code>filter.addAction(DownloadManager.ACTION_DOWNLOAD_COMPLETE); 
</code></pre><p> //  接收下载完成后的广播通知</p>
<pre><code>filter.addAction(DownloadManager.ACTION_NOTIFICATION_CLICKED);
</code></pre><p>上面的都是为了安装更新做准备.</p>
<p>我们看看检查更新:  chenckUpdate();</p>
<pre><code>private void checkUpdate() {
    RetrofitManager.getInstance()
            .getServer()
            .getUpdateVersion()
            .compose(RxUtils.&lt;UpdateAppInfo&gt;apply())
            .subscribe(new Observer&lt;UpdateAppInfo&gt;() {
                @Override
                public void onSubscribe(Disposable d) {
                    Log.d(TAG, &quot;onSubscribe: &quot; + d.toString());
                }
                @Override
                public void onNext(UpdateAppInfo updateAppInfo) {
                    if (TextUtils.equals(&quot;200&quot;, updateAppInfo.getCode())) {
                        String appname = updateAppInfo.getData().getAppname();
                        String serverVersionCode = updateAppInfo.getData().getServerVersionCode();
                        String serverVersionName = updateAppInfo.getData().getServerVersionName();
                        String updateurl = updateAppInfo.getData().getUpdateurl();
                        String updateinfo = updateAppInfo.getData().getUpgradeinfo();
                        String code_msg = updateAppInfo.getCode_msg();
                        Long aLong = Long.parseLong(serverVersionCode);
                        SpUtils.getInstance().putString(UserConstant.UPDATE_URL, updateurl);

                        if (aLong &gt; PackageUtils.getVersionCode(mContext)) {

                            showUpdateConfirmDialog(mContext, updateinfo);
                        }else{
                            // 没有更新
                mHandler.sendEmptyMessage(0x10102);                     
                        }
                    }
                }
                @Override
                public void onError(Throwable e) {
                    Log.d(TAG, &quot;onError: 错误信息&quot; + e);
                }

                @Override
                public void onComplete() {

                }
            });
}
</code></pre><p>Handler也来一段,直接复制:</p>
<pre><code>private  Handler mHandler = new Handler() {
    @Override
    public void handleMessage(Message msg) {
        if (msg.what==0x10102){

           // ToastUtils.showShort(mContext,&quot;执行splash&quot;);
            continueSplash();  // 继续执行splash的动画
        }

    }
};
</code></pre><h3 id="关于continueSplash-方法"><a href="#关于continueSplash-方法" class="headerlink" title="关于continueSplash();方法"></a>关于continueSplash();方法</h3><p> private void continueSplash() {<br>        //计时器定义<br>        final CountDownTimer countDownTimer = new CountDownTimer(3000, 1000) {<br>            @Override<br>            public void onTick(long millisUntilFinished) {<br>            }</p>
<pre><code>        @Override
        public void onFinish() {

            //启动之后，判断是不是第一次启动
            if (SpUtils.getInstance().getBoolean(SPConstant.IS_FIRST_ENTRY, true)) {
                //前往欢迎界面
                Intent intent = new Intent(mContext, WelcomeActivity.class);
                AnimationUtils.startActivity(mContext, intent);
                SpUtils.getInstance().putBoolean(SPConstant.IS_FIRST_ENTRY, false);
                finish();
            } else {
                //前往登录界面
                Intent intent = new Intent(mContext, LoginActivity.class);
                AnimationUtils.startActivity(mContext, intent);
                finish();
            }
        }
    };
    // 如果大于23  使用RxPermissions库来
    if (Build.VERSION.SDK_INT &gt; 23) {
        //请求权限
        RxPermissions rxPermissions = new RxPermissions(SplashActivity.this);
        String[] permissions = {Manifest.permission.WRITE_EXTERNAL_STORAGE};
        rxPermissions.request(permissions)
                .subscribe(new Observer&lt;Boolean&gt;() {
                    @Override
                    public void onSubscribe(Disposable d) {

                    }

                    @Override
                    public void onNext(Boolean aBoolean) {

                    }

                    @Override
                    public void onError(Throwable e) {
                        countDownTimer.start();
                    }

                    @Override
                    public void onComplete() {
                        countDownTimer.start();
                    }
                });
    } else {
        countDownTimer.start();
    }
}
</code></pre><p>缺少文件补充一: <strong>SpUtils.class</strong></p>
<pre><code>public class SpUtils {

private static Context mContext;
private static SharedPreferences sp;
private static SharedPreferences.Editor editor;
private static SpUtils instance;

public static void init(Context context) {
    mContext = context;
    if (mContext != null) {
        sp = mContext.getSharedPreferences(SPConstant.SP_NAME, Context.MODE_PRIVATE);
        editor = sp.edit();
        boolean commit = editor.commit();
    } else {
        throw new IllegalStateException(&quot;init the SharedPreferences first please!&quot;);
    }
}

/**
 * SPUtils构造函数
 */
private SpUtils() {
}

public static SpUtils getInstance() {
    if (mContext != null) {
        if (instance == null) {
            instance = new SpUtils();
        }
    } else {
        throw new IllegalStateException(&quot;init the SharedPreferences first please!&quot;);
    }

    return instance;
}
/**
 * SP中写入String类型value
 *
 * @param key   键
 * @param value 值
 */
public void putString(String key, String value) {
    editor.putString(key, value).commit();
}

/**
 * SP中读取String
 *
 * @param key 键
 * @return 存在返回对应值，不存在返回默认值{@code null}
 */
public String getString(String key) {
    return getString(key, null);
}

/**
 * SP中读取String
 *
 * @param key          键
 * @param defaultValue 默认值
 * @return 存在返回对应值，不存在返回默认值{@code defaultValue}
 */
public String getString(String key, String defaultValue) {
    return sp.getString(key, defaultValue);
}

/**
 * SP中写入int类型value
 *
 * @param key   键
 * @param value 值
 */
public void putInt(String key, int value) {
    editor.putInt(key, value).commit();
}

/**
 * SP中读取int
 *
 * @param key 键
 * @return 存在返回对应值，不存在返回默认值-1
 */
public int getInt(String key) {
    return getInt(key, -1);
}

/**
 * SP中读取int
 *
 * @param key          键
 * @param defaultValue 默认值
 * @return 存在返回对应值，不存在返回默认值{@code defaultValue}
 */
public int getInt(String key, int defaultValue) {
    return sp.getInt(key, defaultValue);
}

/**
 * SP中写入long类型value
 *
 * @param key   键
 * @param value 值
 */
public void putLong(String key, long value) {
    editor.putLong(key, value).commit();
}

/**
 * SP中读取long
 *
 * @param key 键
 * @return 存在返回对应值，不存在返回默认值-1
 */
public long getLong(String key) {
    return getLong(key, -1L);
}

/**
 * SP中读取long
 *
 * @param key          键
 * @param defaultValue 默认值
 * @return 存在返回对应值，不存在返回默认值{@code defaultValue}
 */
public long getLong(String key, long defaultValue) {
    return sp.getLong(key, defaultValue);
}

/**
 * SP中写入float类型value
 *
 * @param key   键
 * @param value 值
 */
public void putFloat(String key, float value) {
    editor.putFloat(key, value).commit();
}

/**
 * SP中读取float
 *
 * @param key 键
 * @return 存在返回对应值，不存在返回默认值-1
 */
public float getFloat(String key) {
    return getFloat(key, -1f);
}

/**
 * SP中读取float
 *
 * @param key          键
 * @param defaultValue 默认值
 * @return 存在返回对应值，不存在返回默认值{@code defaultValue}
 */
public float getFloat(String key, float defaultValue) {
    return sp.getFloat(key, defaultValue);
}

/**
 * SP中写入boolean类型value
 *
 * @param key   键
 * @param value 值
 */
public void putBoolean(String key, boolean value) {
    editor.putBoolean(key, value).commit();
}

/**
 * SP中读取boolean
 *
 * @param key 键
 * @return 存在返回对应值，不存在返回默认值{@code false}
 */
public boolean getBoolean(String key) {
    return getBoolean(key, false);
}

/**
 * SP中读取boolean
 *
 * @param key          键
 * @param defaultValue 默认值
 * @return 存在返回对应值，不存在返回默认值{@code defaultValue}
 */
public boolean getBoolean(String key, boolean defaultValue) {
    return sp.getBoolean(key, defaultValue);
}

/**
 * 获取SP中所有键值对
 *
 * @return Map对象
 */
public Map&lt;String, ?&gt; getAll() {
    return sp.getAll();
}

/**
 * 从SP中移除该key
 *
 * @param key 键
 */
public void remove(String key) {
    editor.remove(key).commit();
}

/**
 * 判断SP中是否存在该key
 *
 * @param key 键
 * @return {@code true}: 存在&lt;br&gt;{@code false}: 不存在
 */
public boolean contains(String key) {
    return sp.contains(key);
}

/**
 * 清除SP中所有数据
 */
public void clear() {
    editor.clear().commit();
}
}
</code></pre><p>缺少文件补充二: AnimationUtils.class:</p>
<pre><code>public class AnimationUtils {

public static void backActivity(Context context) {
    ((Activity) context).overridePendingTransition(R.anim.open_last, R.anim.close_next);
}

public static void startActivity(Context context, Intent intent) {
    context.startActivity(intent);
    ((Activity) context).overridePendingTransition(R.anim.open_next, R.anim.close_last);
}

public static void startActivityForResult(Context context, Intent intent, int code) {
    ((Activity) context).startActivityForResult(intent, code);
    ((Activity) context).overridePendingTransition(R.anim.open_next, R.anim.close_last);
}

public static void startAlphaActivity(Context context, Intent intent) {
    context.startActivity(intent);
    ((Activity) context).overridePendingTransition(R.anim.alpha_open, R.anim.alpha_colse);
}

public static void startAlphaActivityForResult(Context context, Intent intent, int code) {
    ((Activity) context).startActivityForResult(intent, code);
    ((Activity) context).overridePendingTransition(R.anim.alpha_open, R.anim.alpha_colse);
}



}
</code></pre><p>缺少的动画文件:  res新建文件夹anim  </p>
<p>第一个: opne_last.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt;
&lt;translate
    android:interpolator=&quot;@android:anim/accelerate_interpolator&quot;
    android:duration=&quot;400&quot;
    android:fromYDelta=&quot;0&quot;
    android:toYDelta=&quot;0&quot; 
    android:fromXDelta=&quot;-20%p&quot;
    android:toXDelta=&quot;0&quot;/&gt;
&lt;/set&gt;
</code></pre><p>第二个: open_next.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt;
&lt;translate
    android:duration=&quot;400&quot;
    android:fromXDelta=&quot;100%p&quot;
    android:fromYDelta=&quot;0&quot;
    android:interpolator=&quot;@android:anim/accelerate_interpolator&quot;
    android:toXDelta=&quot;0&quot;
    android:toYDelta=&quot;0&quot;/&gt;
&lt;/set&gt;
</code></pre><p>第三个: close_next.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt;
&lt;translate
    android:duration=&quot;400&quot;
    android:fromXDelta=&quot;0&quot;
    android:fromYDelta=&quot;0&quot;
    android:interpolator=&quot;@android:anim/accelerate_interpolator&quot;
    android:toXDelta=&quot;100%p&quot;
    android:toYDelta=&quot;0&quot; /&gt;
&lt;/set&gt;
</code></pre><p>第四个: close_last.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt;
&lt;translate
    android:interpolator=&quot;@android:anim/accelerate_interpolator&quot;
    android:duration=&quot;800&quot;
    android:fromXDelta=&quot;0&quot;
    android:toXDelta=&quot;-20%p&quot;
    android:fromYDelta=&quot;0&quot;
    android:toYDelta=&quot;0&quot;/&gt;
&lt;/set&gt;
</code></pre><p>第五个: alpha_close.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
&lt;alpha
    android:duration=&quot;400&quot;
    android:fromAlpha=&quot;1.0&quot;
    android:interpolator=&quot;@android:anim/linear_interpolator&quot;
    android:toAlpha=&quot;0.0&quot; /&gt;
&lt;/set&gt;
</code></pre><p>第六个: alpha_ipen.xml:</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt;
&lt;alpha
    android:duration=&quot;400&quot;
    android:fromAlpha=&quot;0.0&quot;
    android:interpolator=&quot;@android:anim/linear_interpolator&quot;
    android:toAlpha=&quot;1.0&quot; /&gt;
&lt;/set&gt;
</code></pre><p>缺少文件SPConstant</p>
<pre><code>public interface SPConstant {
public static final String SP_NAME = &quot;spName&quot;;
public static final String IS_FIRST_ENTRY = &quot;isFirstEntry&quot;;

}
</code></pre><h2 id="6-0权限的申请"><a href="#6-0权限的申请" class="headerlink" title="6.0权限的申请"></a>6.0权限的申请</h2><p>具体的细节说明和简单的使用:</p>
<p>具体的细节看我博客: </p>
<p><a href="http://blog.csdn.net/kunkun5love/article/details/73311761" target="_blank" rel="noopener">http://blog.csdn.net/kunkun5love/article/details/73311761</a></p>
<p>github上面的RxPermission的:</p>
<p><a href="https://github.com/tbruyelle/RxPermissions" title="连接地址" target="_blank" rel="noopener">https://github.com/tbruyelle/RxPermissions</a></p>
<p>//  首先是gradle的依赖</p>
<pre><code>dependencies {
compile &apos;com.tbruyelle.rxpermissions2:rxpermissions:0.9.5@aar&apos;
}
</code></pre><p>代码中的使用: </p>
<pre><code>if (Build.VERSION.SDK_INT &gt; 23) {
        //请求权限
        RxPermissions rxPermissions = new RxPermissions(SplashActivity.this);
        String[] permissions = {Manifest.permission.WRITE_EXTERNAL_STORAGE};
        rxPermissions.request(permissions)
                .subscribe(new Observer&lt;Boolean&gt;() {
                    @Override
                    public void onSubscribe(Disposable d) {

                    }

                    @Override
                    public void onNext(Boolean aBoolean) {

                    }

                    @Override
                    public void onError(Throwable e) {
                        countDownTimer.start();
                    }

                    @Override
                    public void onComplete() {
                        countDownTimer.start();
                    }
                });
    }
</code></pre><h2 id="有更新展示更新对话框和下载"><a href="#有更新展示更新对话框和下载" class="headerlink" title="有更新展示更新对话框和下载"></a>有更新展示更新对话框和下载</h2><p>展示跟新的对话框和使用DownloadManager来下载文件. 对网络的判断和提醒,和下载展示进度条</p>
<pre><code> /**
 * 显示更新对话框,包含版本相关信息
 */
private  void showUpdateConfirmDialog(final Context context, final String updateInfo) {
    new AlertDialog.Builder(context)
            .setTitle(&quot;发现新版本&quot;)
            .setMessage(updateInfo)
            .setPositiveButton(&quot;立即更新&quot;, new DialogInterface.OnClickListener() {
                @Override
                public void onClick(DialogInterface dialog, int which) {
                    if (NetUtils.isWifi(context)) {
                        downLoadApp(context);
                    } else {

                        // 是不是需要坚持手机网络下载
                             new AlertDialog.Builder(context)
                                .setTitle(&quot;流量提醒&quot;)
                                .setMessage(&quot;你正在使用移动流量,是否坚持手机网络下载&quot;)
                                .setPositiveButton(&quot;是&quot;, new DialogInterface.OnClickListener() {
                                    @Override
                                    public void onClick(DialogInterface dialog, int which) {
                                        downLoadApp(context);
                                    }
                                })
                                .setNegativeButton(&quot;不是&quot;, new DialogInterface.OnClickListener() {
                                    @Override
                                    public void onClick(DialogInterface dialog, int which) {
                                        mHandler.sendEmptyMessage(0x10102);
                                    }
                                });


                    }
                }
            })
            .setNegativeButton(&quot;以后再说&quot;, new DialogInterface.OnClickListener() {
                @Override
                public void onClick(DialogInterface dialog, int which) {
                    mHandler.sendEmptyMessage(0x10102);
                }
            })
            .show();
}

/**
 * 下载文件
 *
 * @param context
 */
public static void downLoadApp(Context context) {
    //downurl:下载app的后台地址

    String downurl = &quot;http://59.110.139.99/apk/fabei.apk&quot;;
    DownloadManager.Request request = new DownloadManager.Request(Uri.parse(downurl));
    //  下载时的网络状态，默认是wifi和移动网络都可以下载，如果选择一个，只能在选中的状态下进行下载
    //request.setAllowedNetworkTypes(DownloadManager.Request.NETWORK_MOBILE);
    request.setNotificationVisibility(DownloadManager.Request.VISIBILITY_VISIBLE);
    request.setTitle(&quot;app更新&quot;);
    request.setDescription(&quot;app正在下载&quot;);
    request.setAllowedOverRoaming(false);
    //设置文件存放目录
    //判断文件是否存在，保证其唯一性
    File file = context.getExternalFilesDir(&quot;Download/ccyj&quot;);
    if (file.exists()) {
        file.delete();
    }
    request.setDestinationInExternalFilesDir(context, Environment.DIRECTORY_DOWNLOADS, &quot;downapp&quot;);
    DownloadManager downManager = (DownloadManager) context.getApplicationContext().getSystemService(Context.DOWNLOAD_SERVICE);
    long id = downManager.enqueue(request);
    // 存储下载Key
    SharedPreferences sharedPreferences = context.getSharedPreferences(&quot;downloadapp&quot;, Activity.MODE_PRIVATE);
    SharedPreferences.Editor editor = sharedPreferences.edit();
    editor.putLong(&quot;downloadid&quot;, id);
    editor.commit();
}
</code></pre><p>上面中缺失的文件:</p>
<pre><code>public class NetUtils {

/**
 * 判断是否是wifi连接
 */
public static boolean isWifi(Context context) {
    ConnectivityManager cm = (ConnectivityManager)
            context.getSystemService(Context.CONNECTIVITY_SERVICE);

    if (null == cm) {
        return false;
    }

    NetworkInfo info = cm.getActiveNetworkInfo();
    if (null != info) {
        if (info.getType() == ConnectivityManager.TYPE_WIFI) {
            return true;
        }
    }
    return false;

}
</code></pre><h2 id="广播接收者和安装apk"><a href="#广播接收者和安装apk" class="headerlink" title="广播接收者和安装apk"></a>广播接收者和安装apk</h2><p>下在完成之后会发西湖广播,action是: ACTION_DOWNLOAD_COMPLETE</p>
<p><img src="https://i.imgur.com/ZLGPMth.jpg" alt="具体的介绍"></p>
<p><strong>动态注册广播在上面(注册就有反注册哦,不要忘记了,还有权限都要声明哦): </strong></p>
<p>我们直接看广播接收者中接收后安装apk的操作;</p>
<pre><code>public class DownLoadCompleteReceiver extends BroadcastReceiver {
@Override
public void onReceive(Context context, Intent intent) {
    if (intent.getAction().equals(DownloadManager.ACTION_DOWNLOAD_COMPLETE)) {
        long id = intent.getLongExtra(DownloadManager.EXTRA_DOWNLOAD_ID, -1);

        // 发送消息关闭 dialog
        Message message = new Message();
        message.what=1010;
        EventBus.getDefault().post(message);

        installApk(context, id);
    } else if (intent.getAction().equals(DownloadManager.ACTION_NOTIFICATION_CLICKED)) {
    }


}
/**
 * 下载完后安装apk
 *
 * @param
 */

// 安装Apk
private void installApk(Context context, long downloadApkId) {
    SharedPreferences sharedPreferences = context.getSharedPreferences(&quot;downloadapp&quot;, Activity.MODE_PRIVATE);
    long id = sharedPreferences.getLong(&quot;downloadid&quot;, 0);

    // 获取存储ID
    if (downloadApkId == id) {
        DownloadManager dManager = (DownloadManager) context.getSystemService(Context.DOWNLOAD_SERVICE);

        Uri downloadFileUri = dManager.getUriForDownloadedFile(downloadApkId);
        if (downloadFileUri != null) {
            Intent install = new Intent(Intent.ACTION_VIEW);
            File apkFile = context.getExternalFilesDir(&quot;Download/downapp&quot;);
            //对Android 版本判断
            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) {
                install.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
                // context.getPackageName() + &quot;.fileprovider&quot;  是配置中的authorities
                Uri contentUri = FileProvider.getUriForFile(context, context.getPackageName() + &quot;.fileprovider&quot;, apkFile);
                install.setDataAndType(contentUri, &quot;application/vnd.android.package-archive&quot;);
            } else {
                install.setDataAndType(Uri.fromFile(apkFile), &quot;application/vnd.android.package-archive&quot;);
            }
            install.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            context.startActivity(install);
        } else {
            ToastUtils.showLong(context,&quot;下载失败&quot;);
        }
    }
}
</code></pre><h1 id="明天将apk的升级和安转和出现的问题进行总结"><a href="#明天将apk的升级和安转和出现的问题进行总结" class="headerlink" title="明天将apk的升级和安转和出现的问题进行总结"></a>明天将apk的升级和安转和出现的问题进行总结</h1><p>下载完毕后出现的问题: </p>
<p><img src="https://i.imgur.com/UPmbFD9.png" alt=""></p>
<p>出现的是已经安装了存在签名冲突的同名的数据包.</p>
<p>原因如下(一): 我此时是直接测试运行,安装的是debug版本,服务器上的是我打包过的版本,有签名等信息,debug的签名是默认的签名;</p>
<p>先安转以前的签名的版本,在运行一般就不会出错了.</p>
<p>还有问题可以参考下面链接的文章:</p>
<p><a href="http://blog.csdn.net/linux_dream_2015/article/details/49890777" target="_blank" rel="noopener">http://blog.csdn.net/linux_dream_2015/article/details/49890777</a></p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android开发 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[小程序代码构成学习]]></title>
      <url>/2018/01/26/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BB%A3%E7%A0%81%E6%9E%84%E6%88%90(%E4%B8%80)/</url>
      <content type="html"><![CDATA[<p>第一次接触到小程序,对于小程序的代码构造和具体的发布情况.是对自己的一个记录.<br><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/quickstart/basic/file.html#JSON-%E9%85%8D%E7%BD%AE" title="代码构成" target="_blank" rel="noopener"> https://mp.weixin.qq.com/debug/wxadoc/dev/quickstart/basic/file.html#JSON-%E9%85%8D%E7%BD%AE</a></p>
<p>基本实现步凑: <a href="https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/new.html" target="_blank" rel="noopener">https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/new.html</a><br><a id="more"></a></p>
<h1 id="先看小程序的代码构建"><a href="#先看小程序的代码构建" class="headerlink" title="先看小程序的代码构建"></a>先看小程序的代码构建</h1><p>我们新建的代码的目录和文件大概目录:</p>
<p><img src="https://i.imgur.com/w85Xhmg.png" alt=""></p>
<p>主要的样式有如下: </p>
<h2 id="第一个就是-json格式的结尾的配置文件"><a href="#第一个就是-json格式的结尾的配置文件" class="headerlink" title="第一个就是 json格式的结尾的配置文件"></a>第一个就是 json格式的结尾的配置文件</h2><h3 id="app-json全局配置文件"><a href="#app-json全局配置文件" class="headerlink" title="app.json全局配置文件"></a>app.json全局配置文件</h3><p>主要的连接地址: <a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html" target="_blank" rel="noopener">https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html</a></p>
<p>我们这个这个小程序的名称是 龙哥之友.<br> 我们看看app.json里面的目录结构.</p>
<p><img src="https://i.imgur.com/vBAAiVX.png" alt=""></p>
<p>app.json是对当前小程序的全局的配置.包括小程序的所有的页面的路劲和界面表现,网络超时时间,和底部的tab等.</p>
<p>我们直接看着这个图片进行一一的而了解:</p>
<h4 id="pages字段"><a href="#pages字段" class="headerlink" title="pages字段"></a>pages字段</h4><p>pages:  主要是描述的是当前小程序的多有页面的路劲.目的是告诉微信客户端,相对应的小程序页面定义在那个目录里面.</p>
<p>下面是全部关于 app.json的配置说明: </p>
<p><img src="https://i.imgur.com/umgCkt5.png" alt=""></p>
<blockquote>
<p>划重点了   关于 app.json下面的 pages字段:<br>我们常见的就是  </p>
</blockquote>
<p><img src="https://i.imgur.com/Z6PSW9r.png" alt=""></p>
<p>文件名不需要写文件后缀，因为框架会自动去寻找路径下 .json, .js, .wxml, .wxss 四个文件进行整合。<br>也就是在index文件夹下面有 index.js和index.wxml和index.wxss</p>
<p><img src="https://i.imgur.com/59FEM8X.png" alt=""></p>
<h4 id="关于window字段"><a href="#关于window字段" class="headerlink" title="关于window字段"></a>关于window字段</h4><p>  关于window字段:window字段:  小程序的所有页面的背景颜色和文字颜色定义都在这里.</p>
<p>具体的定义如下: </p>
<p><img src="https://i.imgur.com/pWfdFXh.png" alt=""></p>
<p>我们展示配置和展示示例的图片展示: </p>
<p><img src="https://i.imgur.com/92GK6ID.png" alt=""></p>
<h4 id="关于tab字段"><a href="#关于tab字段" class="headerlink" title="关于tab字段"></a>关于tab字段</h4><p>小程序是多页面tab组成的时候,切换时显示相应的页面.</p>
<blockquote>
<p>注意点 一 设置的 postion为top时候,不在显示icon图标<br>注意点二: tabBar下面是一个list数组,最少2个最多五个tab,展示顺序和数组顺序一致.</p>
</blockquote>
<p>tabBr配置的展示:</p>
<p><img src="https://i.imgur.com/ZMwEOYJ.png" alt=""></p>
<p>我们可以看到list的数组对应的就是每一组tab的对象,组成是 pagepath(路劲)和tab上展示的文字.</p>
<p>具体的属性的说明: </p>
<p><img src="https://i.imgur.com/UNfIylm.png" alt=""></p>
<h4 id="networkTimeout字段"><a href="#networkTimeout字段" class="headerlink" title="networkTimeout字段"></a>networkTimeout字段</h4><p>设置网络超时时间;</p>
<p>属性具体的说明: </p>
<p><img src="https://i.imgur.com/28NsGx6.png" alt=""></p>
<h4 id="debug字段"><a href="#debug字段" class="headerlink" title="debug字段"></a>debug字段</h4><p><img src="https://i.imgur.com/8bVsK84.png" alt=""></p>
<h3 id="page-json页面配置"><a href="#page-json页面配置" class="headerlink" title="page.json页面配置"></a>page.json页面配置</h3><h3 id="工具配置-project-config-json"><a href="#工具配置-project-config-json" class="headerlink" title="工具配置 project.config.json"></a>工具配置 project.config.json</h3><h2 id="第二种就是-wxml模板文件"><a href="#第二种就是-wxml模板文件" class="headerlink" title="第二种就是: wxml模板文件"></a>第二种就是: wxml模板文件</h2><h2 id="第三种"><a href="#第三种" class="headerlink" title="第三种"></a>第三种</h2><h2 id="第四种文件-json文件"><a href="#第四种文件-json文件" class="headerlink" title="第四种文件 json文件"></a>第四种文件 json文件</h2>]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo 个性化配置(三)]]></title>
      <url>/2018/01/25/Hexo-%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE(%E4%B8%89)/</url>
      <content type="html"><![CDATA[<p>本片博客是在上一篇博客Hexo个性化配置(二)的基础上在写的一篇博客,主要不在一起写的原因是,这是自己配置自己搭建的博客时候变学习边记录的文章,记录的比较详细.放置在一篇上面文章比较长,所以截取一次十中个性化的配置.这是第三篇.涉及到如下的个性化配置: </p>
<ol>
<li>jiathis的配置实现博文的分享</li>
<li>文章的置顶功能</li>
<li>打赏功能的实现</li>
<li>点击爆炸效果(有一篇是实现的是红心的效果)</li>
<li>github来实现域名的绑定</li>
<li>插入音乐</li>
<li>实现站内搜索</li>
<li>关于404公益页面的实现</li>
<li>kkk</li>
<li>kkl<a id="more"></a>
</li>
</ol>
<h1 id="1-jiathis的分享的实现"><a href="#1-jiathis的分享的实现" class="headerlink" title="1.jiathis的分享的实现"></a>1.jiathis的分享的实现</h1><p>在主题配置文件下面搜索 jiathis 我们看到在主题的配置文件中已经给我们配置好了,我们需要的是uid;</p>
<p>官网的链接地址: <a href="http://www.jiathis.com/" title="连接地址" target="_blank" rel="noopener">http://www.jiathis.com/</a></p>
<p><img src="https://i.imgur.com/kE0zy4D.png" alt=""></p>
<p>配置主要的设置: </p>
<p><img src="https://i.imgur.com/Wo2h4uJ.png" alt=""></p>
<p>说明一下子: 我们直接在主题的配置文件中搜索jiathis  直接打开jiathis的开关,配置为true uid丢不需要设置.</p>
<p>最后的结果展示: </p>
<p><img src="https://i.imgur.com/qTNOf2P.png" alt=""></p>
<h1 id="2-文章的置顶功能的实现"><a href="#2-文章的置顶功能的实现" class="headerlink" title="2.文章的置顶功能的实现"></a>2.文章的置顶功能的实现</h1><p>修改插件的内容: 这个插件名称: hexo-generator-index </p>
<p>插件内需要修改文件的名称:  generator.js</p>
<p>路劲: /root/blog/node_modules/hexo-generator-index/lib</p>
<p>图片展示: </p>
<p><img src="https://i.imgur.com/gCsBIcd.png" alt=""></p>
<p>修改替换的代码: </p>
<pre><code>&apos;use strict&apos;;
var pagination = require(&apos;hexo-pagination&apos;);
module.exports = function(locals){
  var config = this.config;
  var posts = locals.posts;
posts.data = posts.data.sort(function(a, b) {
    if(a.top &amp;&amp; b.top) { // 两篇文章top都有定义
        if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排
        else return b.top - a.top; // 否则按照top值降序排
    }
    else if(a.top &amp;&amp; !b.top) { // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233）
        return -1;
    }
    else if(!a.top &amp;&amp; b.top) {
        return 1;
    }
    else return b.date - a.date; // 都没定义按照文章日期降序排
});
  var paginationDir = config.pagination_dir || &apos;page&apos;;
  return pagination(&apos;&apos;, posts, {
    perPage: config.index_generator.per_page,
    layout: [&apos;index&apos;, &apos;archive&apos;],
    format: paginationDir + &apos;/%d/&apos;,
    data: {
      __index: true
    }
  });
};
</code></pre><p>我们还需要在咋子hexo的Front-matter也就是我们创建的Hexo的使用 —分割开的部分区域里面设置top属性值   注意属性设置的时候的空格.数值越大越靠前.</p>
<p> 我们在我们的模板中添加top属性,不在我们自己添加了.</p>
<p>路劲:   /root/blog/scaffolds<br>修改的文件就是 post.md文件.</p>
<p>添加top属性.</p>
<p>最后设置完毕的展示效果: </p>
<p><img src="https://i.imgur.com/TVzIniZ.png" alt=""></p>
<h1 id="3-打赏功能的实现"><a href="#3-打赏功能的实现" class="headerlink" title="3.打赏功能的实现"></a>3.打赏功能的实现</h1><p>打赏功能一个是微信的我二维码一个支付宝的二维码,我们分别来获取这个两个二维码.</p>
<h2 id="获取微信的打赏二维码-设置金额"><a href="#获取微信的打赏二维码-设置金额" class="headerlink" title="获取微信的打赏二维码,设置金额"></a>获取微信的打赏二维码,设置金额</h2><p>这个自己设置: 先贴个码.</p>
<p><img src="https://i.imgur.com/VXQvIm8.jpg" alt="赞赏码"></p>
<h2 id="设置支付宝的打赏二维码和金额"><a href="#设置支付宝的打赏二维码和金额" class="headerlink" title="设置支付宝的打赏二维码和金额"></a>设置支付宝的打赏二维码和金额</h2><p><img src="https://i.imgur.com/w6Stqqx.jpg" alt=""></p>
<h2 id="上传图片source-image中"><a href="#上传图片source-image中" class="headerlink" title="上传图片source/image中"></a>上传图片source/image中</h2><h2 id="在主题配置文件中设置"><a href="#在主题配置文件中设置" class="headerlink" title="在主题配置文件中设置"></a>在主题配置文件中设置</h2><p><img src="https://i.imgur.com/ipZ54tz.png" alt=""></p>
<p>去掉注释,设置图片就OK了!<br>最后是结果的展示: </p>
<p><img src="https://i.imgur.com/XFx5N2q.png" alt=""></p>
<h1 id="4-实现爆炸效果"><a href="#4-实现爆炸效果" class="headerlink" title="4.实现爆炸效果"></a>4.实现爆炸效果</h1><p>新建js 命名: fireworks.js  放置的路劲: themes/next/source/js/src </p>
<p>代码的内容如下: </p>
<pre><code>&quot;use strict&quot;;function updateCoords(e){pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top}function setParticuleDirection(e){var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return{x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)}}function createParticule(e,t){var a={};return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function(){ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()},a}function createCircle(e,t){var a={};return a.x=e,a.y=t,a.color=&quot;#F00&quot;,a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function(){ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1},a}function renderParticule(e){for(var t=0;t&lt;e.animatables.length;t++){e.animatables[t].target.draw()}}function animateParticules(e,t){for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++){n.push(createParticule(e,t))}anime.timeline().add({targets:n,x:function(e){return e.endPos.x},y:function(e){return e.endPos.y},radius:0.1,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule}).add({targets:a,radius:anime.random(80,160),lineWidth:0,alpha:{value:0,easing:&quot;linear&quot;,duration:anime.random(600,800)},duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule,offset:0})}function debounce(e,t){var a;return function(){var n=this,i=arguments;clearTimeout(a),a=setTimeout(function(){e.apply(n,i)},t)}}var canvasEl=document.querySelector(&quot;.fireworks&quot;);if(canvasEl){var ctx=canvasEl.getContext(&quot;2d&quot;),numberOfParticules=30,pointerX=0,pointerY=0,tap=&quot;mousedown&quot;,colors=[&quot;#FF1461&quot;,&quot;#18FF92&quot;,&quot;#5A87FF&quot;,&quot;#FBF38C&quot;],setCanvasSize=debounce(function(){canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+&quot;px&quot;,canvasEl.style.height=window.innerHeight+&quot;px&quot;,canvasEl.getContext(&quot;2d&quot;).scale(2,2)},500),render=anime({duration:1/0,update:function(){ctx.clearRect(0,0,canvasEl.width,canvasEl.height)}});document.addEventListener(tap,function(e){&quot;sidebar&quot;!==e.target.id&amp;&amp;&quot;toggle-sidebar&quot;!==e.target.id&amp;&amp;&quot;A&quot;!==e.target.nodeName&amp;&amp;&quot;IMG&quot;!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))},!1),setCanvasSize(),window.addEventListener(&quot;resize&quot;,setCanvasSize,!1)}&quot;use strict&quot;;function updateCoords(e){pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top}function setParticuleDirection(e){var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return{x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)}}function createParticule(e,t){var a={};return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function(){ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()},a}function createCircle(e,t){var a={};return a.x=e,a.y=t,a.color=&quot;#F00&quot;,a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function(){ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1},a}function renderParticule(e){for(var t=0;t&lt;e.animatables.length;t++){e.animatables[t].target.draw()}}function animateParticules(e,t){for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++){n.push(createParticule(e,t))}anime.timeline().add({targets:n,x:function(e){return e.endPos.x},y:function(e){return e.endPos.y},radius:0.1,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule}).add({targets:a,radius:anime.random(80,160),lineWidth:0,alpha:{value:0,easing:&quot;linear&quot;,duration:anime.random(600,800)},duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule,offset:0})}function debounce(e,t){var a;return function(){var n=this,i=arguments;clearTimeout(a),a=setTimeout(function(){e.apply(n,i)},t)}}var canvasEl=document.querySelector(&quot;.fireworks&quot;);if(canvasEl){var ctx=canvasEl.getContext(&quot;2d&quot;),numberOfParticules=30,pointerX=0,pointerY=0,tap=&quot;mousedown&quot;,colors=[&quot;#FF1461&quot;,&quot;#18FF92&quot;,&quot;#5A87FF&quot;,&quot;#FBF38C&quot;],setCanvasSize=debounce(function(){canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+&quot;px&quot;,canvasEl.style.height=window.innerHeight+&quot;px&quot;,canvasEl.getContext(&quot;2d&quot;).scale(2,2)},500),render=anime({duration:1/0,update:function(){ctx.clearRect(0,0,canvasEl.width,canvasEl.height)}});document.addEventListener(tap,function(e){&quot;sidebar&quot;!==e.target.id&amp;&amp;&quot;toggle-sidebar&quot;!==e.target.id&amp;&amp;&quot;A&quot;!==e.target.nodeName&amp;&amp;&quot;IMG&quot;!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))},!1),setCanvasSize(),window.addEventListener(&quot;resize&quot;,setCanvasSize,!1)};
</code></pre><p>之后在themes/next/layout/_layout.swig 添加下面代码:</p>
<pre><code>{% if theme.fireworks %}
	   <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;"></canvas> 
	   <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
	   <script type="text/javascript" src="/js/src/fireworks.js"></script>
	{% endif %}
</code></pre><p>添加的位置: 在前面添加  最后没有实现还是小桃心效果(只是在hexo配置三哪一篇文章的上部实现了这个效果).</p>
<p><img src="https://i.imgur.com/JRxsOu7.png" alt=""></p>
<p>最后在主题配置文件中配置:</p>
<p> fireworks: true</p>
<p>展示一下: </p>
<p><img src="https://i.imgur.com/lZPfZ1D.png" alt=""></p>
<h1 id="5-github-pages-Hexo搭建"><a href="#5-github-pages-Hexo搭建" class="headerlink" title="5.github pages+Hexo搭建"></a>5.github pages+Hexo搭建</h1><h2 id="具体的总结"><a href="#具体的总结" class="headerlink" title="具体的总结"></a>具体的总结</h2><p>这个在搭配的时候稍微出现了点问题主要是DNS解析这一块, 上一个搭建完成的 <a href="http://kunkun5love.club" title="自己搭建的独立博客" target="_blank" rel="noopener">http://kunkun5love.club</a></p>
<p>至于获取github page 在下面有博文有具体的说明.  主要总结的是 申请域名后将申请的域名通过dns跳转到我们的github page 页面上.</p>
<p>例如: 我的域名是 <a href="kunkun5love.club">kunkun5love.club</a>   我获取的github page 的 <a href="NYK1024212458.github.io">NYK1024212458.github.io</a>;  实质实现就是浏览器输入 kunkunlove.club 后跳转到 NYK1024212458.github.io,我们将hexo生成的 根目录下面的public目录下的文件上传到我们的仓库中,静态的网址.</p>
<h3 id="第一步将hexo的public-目录上传到NYK1024212458-github-io仓库"><a href="#第一步将hexo的public-目录上传到NYK1024212458-github-io仓库" class="headerlink" title="第一步将hexo的public 目录上传到NYK1024212458.github.io仓库"></a>第一步将hexo的public 目录上传到NYK1024212458.github.io仓库</h3><p>创建NYK1024212458.github.io仓库(详细在下面)</p>
<p>安装 git(安装Hexo框架的时候初始化了,没有的自己安装),配置秘钥等下面的文章中有详细的步骤</p>
<p>上传public文件到 github 的仓库 操作图片如下: </p>
<p><img src="https://i.imgur.com/Nhaw9Pm.png" alt="">   使用的hexo的命令是 hexo d </p>
<blockquote>
<p>hexo g 是生成静态的文件</p>
</blockquote>
<p>上传上去,此时要是我们访问 <a href="NYK1024212458.github.io">NYK1024212458.github.io</a> 已经可以访问,这个访问的域名比较难记,我们使用跳转.</p>
<blockquote>
<p>注意 在仓库创建文件 CNAME  内容 : kunkun5love.club<br>也可以在hexo的 source 目录下创建CNAME 文件 内容就是 kunkun5love.club 每一次hexo d 部署到github上的时候会覆盖仓库创建的文件.</p>
</blockquote>
<h3 id="kunkun5love-club的跳转"><a href="#kunkun5love-club的跳转" class="headerlink" title="kunkun5love.club的跳转"></a>kunkun5love.club的跳转</h3><p>首先是我们获取我们要跳转的域名的IP地址: 比如我们要跳转 <a href="NYK1024212458.github.io">NYK1024212458.github.io</a>,我们ping一下子</p>
<p> 操作如下: 打开win+r 输入: cmd 回车   输入 ping NYK1024212458.github.io 回车 (注意NYK1024212458替换这是我的)</p>
<p><img src="https://i.imgur.com/bxLuTpz.png" alt=""></p>
<p>接下来就是 域名的dns配置</p>
<p><img src="https://i.imgur.com/H49SZYB.png" alt=""></p>
<p>添加的第一个记录就是 A标记  记录值就是 我们的ip地址  之后添加一个  CNAME 标记   记录值就是  NYK1024212458.github.io</p>
<p>如果出现问题在下面展示的标志位置不会显示连接: </p>
<p><img src="https://i.imgur.com/aiNg09G.png" alt=""></p>
<h2 id="git的安装和email和name的配置"><a href="#git的安装和email和name的配置" class="headerlink" title="git的安装和email和name的配置"></a>git的安装和email和name的配置</h2><p>这个操作有自己的详细的博客地址:</p>
<p><a href="http://blog.csdn.net/kunkun5love/article/details/71915498" target="_blank" rel="noopener">http://blog.csdn.net/kunkun5love/article/details/71915498</a></p>
<h2 id="注册github来创建-repositories"><a href="#注册github来创建-repositories" class="headerlink" title="注册github来创建 repositories"></a>注册github来创建 repositories</h2><p>注册github,根据提醒注册一个github,操作失败的请移步下面的连接地址:<a href="https://baijiahao.baidu.com/s?id=1573372372409235&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1573372372409235&amp;wfr=spider&amp;for=pc</a>,</p>
<p>进入自己的页面;图片展示如下</p>
<p><img src="https://i.imgur.com/9meRnNB.png" alt=""></p>
<p>进入创建的页面,展示如下:</p>
<p><img src="https://i.imgur.com/YO6IjTW.png" alt=""></p>
<p>点击new repositories 创建来获取github page</p>
<p><img src="https://i.imgur.com/iKR9MHB.png" alt=""></p>
<p>说明一下子: 新建的名字必须和你github上面的名称一致,将上面NYK1024212458修改为你的github账户就行,结尾.github.io结尾,我已经创建过一次,这一次只是为了展示说明,注意要初始化一个Readme的文件,也就是最后一个要勾选.</p>
<p>创建完毕就是获取我们创建仓库的github page ,进入我们刚刚创建的仓库,点击setting</p>
<p><img src="https://i.imgur.com/ocLIBOV.png" alt=""></p>
<p>获取githubpage:</p>
<p><img src="https://i.imgur.com/L9ItxKJ.png" alt=""></p>
<p>首先是自己的创建的gitpage  <a href="https://nyk1024212458.github.io/" target="_blank" rel="noopener">https://nyk1024212458.github.io/</a></p>
<p>访问的结果如此:</p>
<p><img src="https://i.imgur.com/UkLHpvr.png" alt=""></p>
<p>获取ssh,后面在hexo的主题配置中会使用到</p>
<p>ssh:  <a href="git@github.com:NYK1024212458/NYK1024212458.github.io.git">git@github.com:NYK1024212458/NYK1024212458.github.io.git</a></p>
<h2 id="将我们申请的其他域名与github申请的空间绑定"><a href="#将我们申请的其他域名与github申请的空间绑定" class="headerlink" title="将我们申请的其他域名与github申请的空间绑定"></a>将我们申请的其他域名与github申请的空间绑定</h2><p>首先是在github上面的 刚获取的githubpage里面新建一个文件名称是 CNAME 没有后缀,内容就是我们在阿里云或者是其他地方申请的域名,至于域名现在都要实名制,要备案,这些有官方的说明,按着操作就可以了.</p>
<p>例如我的域名在腾讯云上申请的 kunkun5love.tk  ,我们CNAME 里面的内容就是 kunkun5love.club</p>
<p>这个CNAME需要上传到我们的初始化的Hexo的博客文件中去,位置就是 初始化的文件夹(执行 hexo init 文件夹的名称) /source 下面</p>
<p>展示如下: </p>
<p><img src="https://i.imgur.com/KRojUGc.png" alt=""></p>
<h2 id="设置自己域名的DNS设置"><a href="#设置自己域名的DNS设置" class="headerlink" title="设置自己域名的DNS设置"></a>设置自己域名的DNS设置</h2><p> 推荐的是DNSpod: </p>
<p>连接地址: <a href="https://www.dnspod.cn/" title="DNSpod" target="_blank" rel="noopener">https://www.dnspod.cn/</a></p>
<p>首先是添加你申请的域名,之后是添加解析:</p>
<p><img src="https://i.imgur.com/H49SZYB.png" alt=""></p>
<h2 id="Hexo中的配置"><a href="#Hexo中的配置" class="headerlink" title="Hexo中的配置"></a>Hexo中的配置</h2><p>安装的扩展插件: </p>
<pre><code>npm install hexo-deployer-git --save
</code></pre><p>展示图片: </p>
<p><img src="https://i.imgur.com/1qADNFh.png" alt=""></p>
<p>在站点配置文件的设置: </p>
<p><img src="https://i.imgur.com/Sfw4RRE.png" alt=""></p>
<h1 id="6-插入音乐"><a href="#6-插入音乐" class="headerlink" title="6.插入音乐"></a>6.插入音乐</h1><h2 id="进入网页版的歌曲页面获取外部播放连接"><a href="#进入网页版的歌曲页面获取外部播放连接" class="headerlink" title="进入网页版的歌曲页面获取外部播放连接"></a>进入网页版的歌曲页面获取外部播放连接</h2><p>我们首先是登录网易云: </p>
<p><a href="http://music.163.com/" title="网易云" target="_blank" rel="noopener">http://music.163.com/</a></p>
<p>点击自己要插入音乐的首页:  目的是获取播放的外链   展示如下:</p>
<p><img src="https://i.imgur.com/tsc2TYA.png" alt=""></p>
<h2 id="直接复制歌曲的播放代码到博客中"><a href="#直接复制歌曲的播放代码到博客中" class="headerlink" title="直接复制歌曲的播放代码到博客中"></a>直接复制歌曲的播放代码到博客中</h2><p>复制代码,直接到博客中:  我复制的代码如下</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=34383004&auto=1&height=66"></iframe>

<p>下面的是flash代码:</p>
<embed src="//music.163.com/style/swf/widget.swf?sid=34383004&type=2&auto=1&width=320&height=66" width="340" height="86" allownetworking="all">

<p> 我们上传到hexo试试:</p>
<p><img src="https://i.imgur.com/IHQGHgp.png" alt=""></p>
<p>说明一下子,win10自带的浏览器是两种都支持的,火狐flash插件的问题,不能播放.</p>
<p>抽时间写一篇关于火狐flash的处理.</p>
<h1 id="7-增加一个站内搜索"><a href="#7-增加一个站内搜索" class="headerlink" title="7.增加一个站内搜索"></a>7.增加一个站内搜索</h1><h2 id="第一步那转搜索插件"><a href="#第一步那转搜索插件" class="headerlink" title="第一步那转搜索插件"></a>第一步那转搜索插件</h2><pre><code>npm install hexo-generator-search --save
</code></pre><p>安装展示图片: </p>
<p><img src="https://i.imgur.com/wX6Jw6K.png" alt=""></p>
<h2 id="站点配置"><a href="#站点配置" class="headerlink" title="站点配置"></a>站点配置</h2><p><img src="https://i.imgur.com/azUXT7H.png" alt=""></p>
<h1 id="8-关于404公益页面的实现"><a href="#8-关于404公益页面的实现" class="headerlink" title="8.关于404公益页面的实现"></a>8.关于404公益页面的实现</h1><p>我们在前面实现了域名跳转到github page页面 我们实现的是腾讯的404页面 </p>
<p>连接地址: <a href="http://www.qq.com/404/" title="腾讯的404页面" target="_blank" rel="noopener">http://www.qq.com/404/</a> </p>
<p>主要的操作就是复制里面的js代码到我们的404页面中.</p>
<p>在hexo的source 里面新建404.html 编写html文件: </p>
<p><img src="https://i.imgur.com/LxHj7N9.png" alt=""></p>
<p>代码复制: </p>
<pre><code>&lt; !DOCTYPE html&gt;
&lt;html lang =&quot;en&quot;&gt;
&lt;head&gt;
     &lt;meta charset=&quot;UTF-8&quot;&gt;
     &lt;title&gt;404页面&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre><p>我们上传后,配置我们主页的404显示界面,直接指定到404.html文件,配置如下: </p>
<p> <img src="https://i.imgur.com/aVDtMHY.png" alt=""></p>
<p>最后博客的展示页面:<br><img src="https://i.imgur.com/0oGCjL6.png" alt=""></p>
<p>最后来一个参考博客: <a href="http://www.foreverpx.cn/2014/09/23/hexo404/" target="_blank" rel="noopener">http://www.foreverpx.cn/2014/09/23/hexo404/</a></p>
<h1 id="9"><a href="#9" class="headerlink" title="9."></a>9.</h1><h1 id="10"><a href="#10" class="headerlink" title="10."></a>10.</h1>]]></content>
      
        <categories>
            
            <category> 博客 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo的个性化配置(二)]]></title>
      <url>/2018/01/22/Hexo%E7%9A%84%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE(%E4%BA%8C)/</url>
      <content type="html"><![CDATA[<h1 id="Hexo的个性化配置二"><a href="#Hexo的个性化配置二" class="headerlink" title="Hexo的个性化配置二"></a>Hexo的个性化配置二</h1><p>接上一篇的Hexo的个性化配置,都是一些提高网站个性化的配置,只是搭建一个简单的Hexo的网站的话,查看Hexo的使用就行.可能写的比较啰嗦,详细还是很详细的,也是自己就出Hexo的一个记录.<br><a id="more"></a></p>
<h2 id="1-Hexo之文章阅读结束后出现-感谢大家的阅读"><a href="#1-Hexo之文章阅读结束后出现-感谢大家的阅读" class="headerlink" title="1.Hexo之文章阅读结束后出现 感谢大家的阅读!"></a>1.Hexo之文章阅读结束后出现 感谢大家的阅读!</h2><h3 id="添加新的文件"><a href="#添加新的文件" class="headerlink" title="添加新的文件"></a>添加新的文件</h3><p>修改下面路劲下的文件:</p>
<p>/themes/next/layout/_macro 路劲下新建文件:</p>
<p>文件名称: passage-end-tag.swig</p>
<p>并且添加下面内容的标签-内容如下:</p>
<pre><code>&lt;div&gt;
{% if not is_index %}
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读!-------------</div>
    {% endif %}
&lt;/div&gt;
</code></pre><h3 id="将新建的添加到-post-swig文件中"><a href="#将新建的添加到-post-swig文件中" class="headerlink" title="将新建的添加到 post.swig文件中"></a>将新建的添加到 post.swig文件中</h3><p>文件的路劲: themes/next/lauyout/_macro/post.swig 文件中.</p>
<p><img src="https://i.imgur.com/rR80D7V.png" alt=""></p>
<p>展示图片:</p>
<p><img src="https://i.imgur.com/65bR3To.png" alt=""></p>
<blockquote>
<p>注意  我没有在主题的配置文件中添加下面的代码最后也显示正常.我试试配置之后出现什情况.</p>
</blockquote>
<p>配置的如下:</p>
<pre><code># 文章末尾添加“本文结束”标记
passage_end_tag:
  enabled: true
</code></pre><p>最后的结果是也没有什么变化,如果大家设置完毕之后出现不显示字体,可以尝试在主题的配置文件中添加这个配置,虽然不一定可以解决这个问题,也算是一种尝试.</p>
<h2 id="2-实现点击个人图标实现图片的旋转"><a href="#2-实现点击个人图标实现图片的旋转" class="headerlink" title="2.实现点击个人图标实现图片的旋转"></a>2.实现点击个人图标实现图片的旋转</h2><p>在主题下面的资源中修改工具栏的样式.</p>
<p>路劲: themes/next/source/css/_common/components/sidebar/sidebar-author.style</p>
<p>路劲的展示图片:</p>
<p><img src="https://i.imgur.com/EDYrlkM.png" alt=""></p>
<p>添加的代码如下: </p>
<pre><code>    /* 头像圆形 */
  border-radius: 80px;
  -webkit-border-radius: 80px;
  -moz-border-radius: 80px;
  box-shadow: inset 0 -1px 0 #333sf;

  /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 
    (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/


  /* 鼠标经过头像旋转360度 */
  -webkit-transition: -webkit-transform 1.0s ease-out;
  -moz-transition: -moz-transform 1.0s ease-out;
  transition: transform 1.0s ease-out;
}

img:hover {
  /* 鼠标经过停止头像旋转 
  -webkit-animation-play-state:paused;
  animation-play-state:paused;*/

  /* 鼠标经过头像旋转360度 */
  -webkit-transform: rotateZ(360deg);
  -moz-transform: rotateZ(360deg);
  transform: rotateZ(360deg);
}

/* Z 轴旋转动画 */
@-webkit-keyframes play {
  0% {
    -webkit-transform: rotateZ(0deg);
  }
  100% {
    -webkit-transform: rotateZ(-360deg);
  }
}
@-moz-keyframes play {
  0% {
    -moz-transform: rotateZ(0deg);
  }
  100% {
    -moz-transform: rotateZ(-360deg);
  }
}
@keyframes play {
  0% {
    transform: rotateZ(0deg);
  }
  100% {
    transform: rotateZ(-360deg);
  }

}
</code></pre><p>添加的位置如下: </p>
<p><img src="https://i.imgur.com/HRmkbMC.png" alt=""></p>
<p>结束位置如下: </p>
<p><img src="https://i.imgur.com/kUAJtGM.png" alt=""></p>
<h2 id="3-文章中代码块的样式的自定义"><a href="#3-文章中代码块的样式的自定义" class="headerlink" title="3.文章中代码块的样式的自定义"></a>3.文章中代码块的样式的自定义</h2><p>之前的样式展示:</p>
<p><img src="https://i.imgur.com/FbDmw84.png" alt=""></p>
<p>修改的演示的路劲: </p>
<p> /root/blog/themes/next/source/css/_custom下面的custom.styl文件</p>
<p>添加的内容如下:</p>
<pre><code>// Custom styles.


code {

    color: #ff7600;
    background: #fbf7f8;
    margin: 2px;

}

// 大代码块的自定义样式

.highlight, pre {
    margin: 5px 0;
    padding: 5px;
    border-radius: 3px;
}
.highlight, code, pre {
    border: 1px solid #d6d6d6;
}
</code></pre><p>最后的展示结果表示很难看,连接划过之后变成黄色.大段的代码块非常的难看.</p>
<p>自己最后注释掉自定义的样式.</p>
<h2 id="4侧边脸社交图标的设置"><a href="#4侧边脸社交图标的设置" class="headerlink" title="4侧边脸社交图标的设置"></a>4侧边脸社交图标的设置</h2><p>修改的是主题配置文件:</p>
<p>关键字就是: social  社交的意思</p>
<p><img src="https://i.imgur.com/Lee4BRN.png" alt=""></p>
<p>自己可以选择的图标的库: <a href="http://fontawesome.io/icons/" title="选择的库的图标" target="_blank" rel="noopener">http://fontawesome.io/icons/</a></p>
<p>最后自己的配置:</p>
<p><img src="https://i.imgur.com/HDh0jdQ.png" alt=""></p>
<p>结果的展示: </p>
<p><img src="https://i.imgur.com/3CMu7fW.png" alt=""></p>
<h2 id="5-在网站的底部加上访问数量"><a href="#5-在网站的底部加上访问数量" class="headerlink" title="5.在网站的底部加上访问数量"></a>5.在网站的底部加上访问数量</h2><p>修改的代码途径: </p>
<p>/themes/next/layout/_partials.swig 文件</p>
<p>js代码如下: </p>
<pre><code>&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;
</code></pre><p>这个url地址: <a href="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" target="_blank" rel="noopener">https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js</a></p>
<p> 访问后的展示图片如下: </p>
<p><img src="https://i.imgur.com/SSBwXB9.png" alt=""></p>
<p>添加访问的统计的代码: </p>
<pre><code>&lt;div class=&quot;powered-by&quot;&gt;
&lt;i class=&quot;fa fa-user-md&quot;&gt;&lt;/i&gt;&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt;
  我的网站的访客数:&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;
&lt;/span&gt;
&lt;/div&gt;
</code></pre><p>图片的展示: </p>
<p><img src="https://i.imgur.com/SPTAeF6.png" alt=""></p>
<p>最后展示结果: </p>
<p><img src="https://i.imgur.com/m2GtZg7.png" alt=""></p>
<h2 id="6-实现网站底部对字数的统计"><a href="#6-实现网站底部对字数的统计" class="headerlink" title="6.实现网站底部对字数的统计"></a>6.实现网站底部对字数的统计</h2><h3 id="第一步安装wordcount"><a href="#第一步安装wordcount" class="headerlink" title="第一步安装wordcount"></a>第一步安装wordcount</h3><p>在博客的根目录下面执行下面的命令:</p>
<pre><code>npm install hexo-wordcount --save
</code></pre><p>安装展示图片: </p>
<p><img src="https://i.imgur.com/WIWJk8w.png" alt=""></p>
<p>之后修改的文件的位置;</p>
<p>  然后在/themes/next/layout/_partials/footer.swig文件尾部加上：</p>
<pre><code>&lt;div class=&quot;theme-info&quot;&gt;
  &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt;
  &lt;span class=&quot;post-count&quot;&gt;博客全站共{{ totalcount(site) }}字&lt;/span&gt;
&lt;/div&gt;
</code></pre><p>放置的位置的展示图片: </p>
<p><img src="https://i.imgur.com/axJXwan.png" alt=""></p>
<p>直接放置在最后面就可以了!</p>
<p>最后的展示页面:</p>
<p><img src="https://i.imgur.com/qmG34ld.png" alt=""></p>
<h3 id="快速安装插件后在主题配置文件中开启文章的字数统计和站点的字数统计和阅读大体的时长"><a href="#快速安装插件后在主题配置文件中开启文章的字数统计和站点的字数统计和阅读大体的时长" class="headerlink" title="快速安装插件后在主题配置文件中开启文章的字数统计和站点的字数统计和阅读大体的时长"></a>快速安装插件后在主题配置文件中开启文章的字数统计和站点的字数统计和阅读大体的时长</h3><p>还有就是阅读时间等在我们安装上面的插件之后,可以在主题的配置文件中开启.</p>
<p><img src="https://i.imgur.com/vh0yGPR.png" alt=""></p>
<p>我们看到是wordcount是关闭的,和阅读时间都是关闭的.<br>我们打开看看.</p>
<p>最后是展示结果</p>
<p><img src="https://i.imgur.com/qn9RClK.png" alt=""></p>
<p>我们可以看到文章的字数统计和阅读的时长</p>
<p><img src="https://i.imgur.com/Vx4Pu26.png" alt=""></p>
<p>我们在可以看到一个是主题配置之后出现的全站的字数,一个是自己在foot.swig文件中配置后出现的效果.</p>
<h2 id="7-实现访问博客时候在展示的图标"><a href="#7-实现访问博客时候在展示的图标" class="headerlink" title="7.实现访问博客时候在展示的图标"></a>7.实现访问博客时候在展示的图标</h2><p>favicon :  英文含义就是网站图标</p>
<p>也就是在访问博客的时候在浏览器上显示的图标标就是现在设置的图标.<br>格式都是 .ico的格式.</p>
<p>选择格式的连接地址: <a href="http://www.easyicon.net/" title="i图标地址" target="_blank" rel="noopener">http://www.easyicon.net/</a></p>
<p>大小是 32*32px的大小;  之后下载,重命名为 favicon.ico格式.</p>
<p>之后的操作就是在主题的配置文件中进行配置.</p>
<p>图片上传的位置: themes/next/source/image</p>
<p>并且在主题的配置文件中进行配置: </p>
<pre><code>favicon: 
  small: /images/favicon.ico
  medium: /images/heart_bulb_stars_16px_1209625_easyicon.net.ico
</code></pre><p>图片的展示:<br><img src="https://i.imgur.com/lOztbuX.png" alt=""></p>
<p>说明一点,在hexo 3.0之后 主题配置文件中对于网站的图标的展示分大小  small 和medium ,在上面的选择图标的位置选择16<em>16px和32</em>32px的,上传,在主题配置文件中设置就OK了.</p>
<p>原先的图片展示: </p>
<p><img src="https://i.imgur.com/ZnMGoF5.png" alt=""></p>
<p>修改后图片展示: </p>
<p><img src="https://i.imgur.com/WZTNZOb.png" alt=""></p>
<h2 id="8-添加网页顶部的加载条"><a href="#8-添加网页顶部的加载条" class="headerlink" title="8.添加网页顶部的加载条"></a>8.添加网页顶部的加载条</h2><p>在最新的hexo 3.0 中可以直接在主题的配置文件中修改: </p>
<p><img src="https://i.imgur.com/yzF5xd2.png" alt=""></p>
<p>看到 pace 是false我们直接修改为true  后面的都是加载的样式,我们可以自己选择.</p>
<p>注意的是   pace_theme:  才是我们选择的.</p>
<p>暂时没有实现,不知道哪里的设置出错了.</p>
<h2 id="9-文章底部添加版权信息"><a href="#9-文章底部添加版权信息" class="headerlink" title="9.文章底部添加版权信息"></a>9.文章底部添加版权信息</h2><h3 id="第一个新建的问价路劲如下"><a href="#第一个新建的问价路劲如下" class="headerlink" title="第一个新建的问价路劲如下:"></a>第一个新建的问价路劲如下:</h3><p>themes/next/layout/_macro 新建文件 my-copyright.swig 文件</p>
<p>添加的代码如下: </p>
<pre><code>{% if page.copyright %}
	<div class="my_post_copyright">
	  <script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>
	
	  <!-- JS库 sweetalert 可修改路径 -->
	  <script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"></script>
	  <script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script>
	  <p><span>本文标题:</span><a href="{{ url_for(page.path) }}">{{ page.title }}</a></p>
	  <p><span>文章作者:</span><a href="/" title="访问 {{ theme.author }} 的个人博客">{{ theme.author }}</a></p>
	  <p><span>发布时间:</span>{{ page.date.format("YYYY年MM月DD日 - HH:MM") }}</p>
	  <p><span>最后更新:</span>{{ page.updated.format("YYYY年MM月DD日 - HH:MM") }}</p>
	  <p><span>原始链接:</span><a href="{{ url_for(page.path) }}" title="{{ page.title }}">{{ page.permalink }}</a>
	    <span class="copy-path" title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="{{ page.permalink }}" aria-label="复制成功！"></i></span>
	  </p>
	  <p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p>  
	</div>
	<script> 
	    var clipboard = new Clipboard('.fa-clipboard');
	      $(".fa-clipboard").click(function(){
	      clipboard.on('success', function(){
	        swal({   
	          title: "",   
	          text: '复制成功',
	          icon: "success", 
	          showConfirmButton: true
	          });
	        });
	    });  
	</script>
	{% endif %}
</code></pre><h3 id="第二个新添加的文件"><a href="#第二个新添加的文件" class="headerlink" title="第二个新添加的文件:"></a>第二个新添加的文件:</h3><p>路劲如下: themes/next/source/css/_common/components/post/my-post-copyright.styl : </p>
<p>代码如下: </p>
<pre><code>    .my_post_copyright {
  width: 85%;
  max-width: 45em;
  margin: 2.8em auto 0;
  padding: 0.5em 1.0em;
  border: 1px solid #d3d3d3;
  font-size: 0.93rem;
  line-height: 1.6em;
  word-break: break-all;
  background: rgba(255,255,255,0.4);
}
.my_post_copyright p{margin:0;}
.my_post_copyright span {
  display: inline-block;
  width: 5.2em;
  color: #b5b5b5;
  font-weight: bold;
}
.my_post_copyright .raw {
  margin-left: 1em;
  width: 5em;
}
.my_post_copyright a {
  color: #808080;
  border-bottom:0;
}
.my_post_copyright a:hover {
  color: #a3d2a3;
  text-decoration: underline;
}
.my_post_copyright:hover .fa-clipboard {
  color: #000;
}
.my_post_copyright .post-url:hover {
  font-weight: normal;
}
.my_post_copyright .copy-path {
  margin-left: 1em;
  width: 1em;
  +mobile(){display:none;}
}
.my_post_copyright .copy-path:hover {
  color: #808080;
  cursor: pointer;
}
</code></pre><h3 id="修改的文件一"><a href="#修改的文件一" class="headerlink" title="修改的文件一"></a>修改的文件一</h3><p>修改的文件路径: next/layout/_macro/post.swig 文件</p>
<p>添加的代码如下: </p>
<pre><code>&lt;div&gt;
  {% if not is_index %}
        {% include 'my-copyright.swig' %}
      {% endif %}
&lt;/div&gt;
</code></pre><p>添加的路劲如图所示: </p>
<p><img src="https://i.imgur.com/32qYHo4.png" alt=""></p>
<h3 id="修改的文件二"><a href="#修改的文件二" class="headerlink" title="修改的文件二"></a>修改的文件二</h3><p>在修改一个文件: 路劲如下:   next/sources/css/_common/components/post/post.styl</p>
<p>具体的展示图片如下: </p>
<p><img src="https://i.imgur.com/pZiL5Rg.png" alt=""></p>
<p>最后一步就是设置 copyright: true 我们可以修改一下子模板 根目录/scaffolds/post.md文件.</p>
<p><img src="https://i.imgur.com/w4SfNMZ.png" alt=""></p>
<p>最后的结果展示: </p>
<p><img src="https://i.imgur.com/aBscG33.png" alt=""></p>
<h2 id="10-隐藏底部的强力驱动-power-by-hexo"><a href="#10-隐藏底部的强力驱动-power-by-hexo" class="headerlink" title="10.隐藏底部的强力驱动 power by hexo"></a>10.隐藏底部的强力驱动 power by hexo</h2><p>修改的就是是 footer.swig 文件   </p>
<p>路劲: themes/next/layout/_partials/footer.swig</p>
<p><img src="https://i.imgur.com/GOx2aFJ.png" alt=""></p>
<p>结果展示: </p>
<p><img src="https://i.imgur.com/Ro6zMrp.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> 博客 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo的个性化配置(一)]]></title>
      <url>/2018/01/17/Hexo%E7%9A%84%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE(%E4%B8%80)/</url>
      <content type="html"><![CDATA[<p>本片博客是在集成Hexo的博客大家之后的一些个人性话的操作,也是自己的一个学习笔记,从操作到图片的展示,每一个个性化操作都比较详细,例如Hexo的评论集成,Rss订阅到Fork me on github的操作和添加动态背景图等;点击出现桃心的效果和文章加密访问等.<br><a id="more"></a></p>
<h1 id="1-Hexo评论集成"><a href="#1-Hexo评论集成" class="headerlink" title="1.Hexo评论集成"></a>1.Hexo评论集成</h1><p>学习的连接博客地址: <a href="http://blog.csdn.net/qwerty200696/article/details/78836421" target="_blank" rel="noopener">http://blog.csdn.net/qwerty200696/article/details/78836421</a></p>
<p>这里面集成的是<strong>来必力</strong>的评论系统.</p>
<p>具体的操作过程:</p>
<h2 id="打开来比力的官网"><a href="#打开来比力的官网" class="headerlink" title="打开来比力的官网"></a>打开来比力的官网</h2><p>连接地址如下: <a href="https://livere.com/" title="来必力的官网" target="_blank" rel="noopener">https://livere.com/</a></p>
<p>注册来必力的官网.</p>
<p>也就是邮箱别名和登录密码,之后就是    验证登录;</p>
<p>成功后的页面如下:</p>
<h2 id="安装来比力city版"><a href="#安装来比力city版" class="headerlink" title="安装来比力city版"></a>安装来比力city版</h2><p><img src="https://i.imgur.com/nxYoXqJ.png" alt=""></p>
<p>点击上面的<strong>安装</strong>进行来比力的安装.  我们使用的当然是免费的版本city.</p>
<p><img src="https://i.imgur.com/cmMl12r.png" alt="来比力的安装界面"></p>
<p>点击现在安装之后出现的界面:</p>
<p><img src="https://i.imgur.com/4zqurlp.png" alt="点击现在安装"></p>
<p>在这里解释一下子:网站的连接就是你要设置的网页的地址:  我填写的是自己的博客地址: <a href="http://116.196.91.100:4000/" target="_blank" rel="noopener">http://116.196.91.100:4000/</a></p>
<p>网站名称: 自己的博客名称   网站的类型: 个人.</p>
<h2 id="获取申请的代码"><a href="#获取申请的代码" class="headerlink" title="获取申请的代码"></a>获取申请的代码</h2><p>点击获取代码:</p>
<p><img src="https://i.imgur.com/lrvQ3Tj.png" alt="获取到uid"></p>
<h2 id="在我们的hexo的主题中进行配置"><a href="#在我们的hexo的主题中进行配置" class="headerlink" title="在我们的hexo的主题中进行配置"></a>在我们的hexo的主题中进行配置</h2><p>我使用主题是next, 我们在我们博客的初始化文件夹中寻找 theme 进入找到 next 打开,对_config.yml打开进行配置:</p>
<p><img src="https://i.imgur.com/QAg7tSx.png" alt=""></p>
<p>修改完毕.我们仔细看,还有一个可以配置的commit系统,<strong>有言</strong>后面是对应的地址,我们可以直接访问获取uid之后进行配置.</p>
<h2 id="最后一步就是在hexo的页面开启"><a href="#最后一步就是在hexo的页面开启" class="headerlink" title="最后一步就是在hexo的页面开启"></a>最后一步就是在hexo的页面开启</h2><p>就是在设置tags等出,设置 comments: true  注意空格</p>
<h2 id="最后设置成功后的展示页面"><a href="#最后设置成功后的展示页面" class="headerlink" title="最后设置成功后的展示页面"></a>最后设置成功后的展示页面</h2><p><img src="https://i.imgur.com/QUglUhC.png" alt="展示页面"></p>
<h1 id="2-设置Fork-me-on-Github"><a href="#2-设置Fork-me-on-Github" class="headerlink" title="2.设置Fork me on Github"></a>2.设置Fork me on Github</h1><p>具体的步骤如下:</p>
<p>##第一步选取适合自己的样式代码##</p>
<p>第一种样式的展示图片:<br><img src="https://i.imgur.com/WTgd1iZ.png" alt="样式一的展示图片"><br>选取的样式代码的连接在如下的地址(显示的样式字母 fork me on github):</p>
<p><a href="https://github.com/blog/273-github-ribbons" title="选取样式的连接" target="_blank" rel="noopener">https://github.com/blog/273-github-ribbons</a></p>
<p>还有一种样式就是图标的样式的选取:</p>
<p>图标的展示图片:</p>
<p><img src="https://i.imgur.com/Oct0REx.png" alt="样式二的展示图片"></p>
<p>代码的连接地址如下:</p>
<p><a href="http://tholman.com/github-corners/" title="代码的链接地址" target="_blank" rel="noopener">http://tholman.com/github-corners/</a></p>
<p>根据上面的样式和颜色选择自己的喜欢的样式进行代码的复制.</p>
<h2 id="在主题中进行配置"><a href="#在主题中进行配置" class="headerlink" title="在主题中进行配置"></a>在主题中进行配置</h2><p><strong>/root/blog/themes/next/layout/_layout.swig</strong>文件中进行配置 /root表示的是根目录. next表示的是当前你使用的主题的样式.</p>
<p>具体的配置直接图片中展示:</p>
<p><img src="https://i.imgur.com/K9akZ1A.png" alt="配置的位置"></p>
<blockquote>
<p>注意的是: href 后面是自己的github的地址,记得修改哦!</p>
</blockquote>
<p>最后就是结果的展示页面:</p>
<p><img src="https://i.imgur.com/8y3PdOw.png" alt="结果的展示页面"></p>
<h1 id="3-设置Rss订阅"><a href="#3-设置Rss订阅" class="headerlink" title="3.设置Rss订阅"></a>3.设置Rss订阅</h1><p>Rss 是什么东西:<br><img src="https://i.imgur.com/ByINUda.png" alt=""></p>
<p>来,百度百科连接走一趟: <a href="https://baike.baidu.com/item/rss/24470?fr=aladdin#12" title="Rss" target="_blank" rel="noopener">https://baike.baidu.com/item/rss/24470?fr=aladdin#12</a></p>
<p>用途: <img src="https://i.imgur.com/Th4QdtV.png" alt=""></p>
<p>具体的操作过程就是安装Hexo的插件</p>
<h2 id="安转hexo的feed-消息源-类型分为Rss和Atom两种"><a href="#安转hexo的feed-消息源-类型分为Rss和Atom两种" class="headerlink" title="安转hexo的feed(消息源,类型分为Rss和Atom两种)"></a>安转hexo的feed(消息源,类型分为Rss和Atom两种)</h2><p>安装的位置就在你hexo init初始化的位置,我是直接 hexo init blog,会在根目录下面生成一个blog文件,进入blog进行安装插件.</p>
<pre><code>npm install --save hexo-generator-feed
</code></pre><p>安装结束的展示图片:</p>
<p><img src="https://i.imgur.com/qOJSpan.png" alt="安装结束的展示图片"></p>
<h2 id="在站点配置文件中进行配置"><a href="#在站点配置文件中进行配置" class="headerlink" title="在站点配置文件中进行配置"></a>在站点配置文件中进行配置</h2><p>打开站点的配置文件在最后一行中添加下面的配置:</p>
<pre><code>plugins: hexo-generate-feed
</code></pre><h2 id="还需要的操作就是-配置主题配置文件"><a href="#还需要的操作就是-配置主题配置文件" class="headerlink" title="还需要的操作就是 配置主题配置文件"></a>还需要的操作就是 配置主题配置文件</h2><p>next的主题配置文件修改_config.yml文件中添加:</p>
<p>rss: /atom.xml</p>
<p>最后就是结果的展示图片:</p>
<p><img src="https://i.imgur.com/hXO5OIC.png" alt="Rss的结果展示图片"></p>
<h1 id="4-文章的输入密码访问"><a href="#4-文章的输入密码访问" class="headerlink" title="4.文章的输入密码访问"></a>4.文章的输入密码访问</h1><h2 id="第一步修改主题下面的文件"><a href="#第一步修改主题下面的文件" class="headerlink" title="第一步修改主题下面的文件"></a>第一步修改主题下面的文件</h2><p>主要的是修改的主题下面的文件:</p>
<p> themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig</p>
<blockquote>
<p>我使用的next主题  还需要注意的就是这里面的是head.swig 文件不是header.swif文件.  不然是找不到位置的.</p>
</blockquote>
<p><img src="https://i.imgur.com/rPiKDsK.png" alt="内容和位置"></p>
<p>script代码如下:</p>
<pre><code>&lt;script&gt;
(function(){
    if(&apos;{{ page.password }}&apos;){
        if (prompt(&apos;请输入文章密码&apos;) !== &apos;{{ page.password }}&apos;){
            alert(&apos;密码错误！&apos;);
            history.back();
        }
    }
})();
&lt;/script&gt;
</code></pre><h2 id="在需要加密文章的页面的配置信息"><a href="#在需要加密文章的页面的配置信息" class="headerlink" title="在需要加密文章的页面的配置信息"></a>在需要加密文章的页面的配置信息</h2><p>在页面的配置如下:</p>
<p><img src="https://i.imgur.com/0NoCUj5.png" alt="密码"></p>
<p>在文字页面设置的密码就是需要访问的时候输入的密码.</p>
<p>最后的展示结果展示:</p>
<p><img src="https://i.imgur.com/NYBiIDD.png" alt=""></p>
<h1 id="5-关于添加动态页面的设置"><a href="#5-关于添加动态页面的设置" class="headerlink" title="5.关于添加动态页面的设置"></a>5.关于添加动态页面的设置</h1><p>关于动态页面的设置:</p>
<p>先上一个连接地址: </p>
<p><img src="http://shenzekun.cn/hexo%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E5%8A%A8%E6%80%81%E8%83%8C%E6%99%AF.html" alt="设置动态的背景"></p>
<p>我大体的描述一下子: </p>
<h2 id="若果存在canvas-nest"><a href="#若果存在canvas-nest" class="headerlink" title="若果存在canvas_nest"></a>若果存在canvas_nest</h2><p>直接在主题配置文件中搜索: canvas_nest</p>
<p>若是存在直接设置为true,说明使用的next版本是在5.1.1之上.</p>
<h2 id="在主题配置文件中不存在"><a href="#在主题配置文件中不存在" class="headerlink" title="在主题配置文件中不存在"></a>在主题配置文件中不存在</h2><p>若是在主题的配置文件中没有找到这个文件,那就哪找上面的连接地址来设置.</p>
<pre><code>{% if theme.canvas_nest %}
	<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
	{% endif %}
</code></pre><p>将上面的代码添加到 next/layout/_layout.swig文件中</p>
<p>具体的位置如下: 在 之前添加代码(注意不要放在的后面)</p>
<p> 之后在主题的配置文件中配置:</p>
<pre><code>canvas_nest: true
</code></pre><h1 id="实现点击的桃心效果"><a href="#实现点击的桃心效果" class="headerlink" title="实现点击的桃心效果"></a>实现点击的桃心效果</h1><p>添加打js代码地址: <a href="http://7u2ss1.com1.z0.glb.clouddn.com/love.js" title="桃心效果的js代码" target="_blank" rel="noopener">http://7u2ss1.com1.z0.glb.clouddn.com/love.js</a></p>
<h2 id="获取js代码"><a href="#获取js代码" class="headerlink" title="获取js代码"></a>获取js代码</h2><p>获取到的js代码:</p>
<pre><code>!function(e,t,a){function n(){c(&quot;.heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: &apos;&apos;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}&quot;),o(),r()}function r(){for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)}function o(){var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e){t&amp;&amp;t(),i(e)}}function i(e){var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,d.push({el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()}),t.body.appendChild(a)}function c(e){var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try{a.appendChild(t.createTextNode(e))}catch(t){a.styleSheet.cssText=e}t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)}function s(){return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;}var d=[];e.requestAnimationFrame=function(){return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e){setTimeout(e,1e3/60)}}(),n()}(window,document);
</code></pre><h2 id="新建js代码放置"><a href="#新建js代码放置" class="headerlink" title="新建js代码放置"></a>新建js代码放置</h2><p>在/theme/next/source/js/src这个路劲下面,新建love.js,将上面的代码复制进去.</p>
<p>代码放置位置的展示:</p>
<p><img src="https://i.imgur.com/BHgfD4g.png" alt=""></p>
<h2 id="配置-layout-swig文件"><a href="#配置-layout-swig文件" class="headerlink" title="配置 _layout.swig文件"></a>配置 _layout.swig文件</h2><p>在 themes/next/layout/_layout.swig 文件, 最后部分添加:</p>
<pre><code>&lt;!-- 页面点击小红心 --&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt;
</code></pre><p>在_layout.swig位置的设置展示:</p>
<p><img src="https://i.imgur.com/Ccf6nWA.png" alt=""></p>
<p>最后效果的展示区域:</p>
<p><img src="https://i.imgur.com/YzgH9Jl.png" alt=""></p>
<h1 id="6-修改文章内连接的样式"><a href="#6-修改文章内连接的样式" class="headerlink" title="6.修改文章内连接的样式"></a>6.修改文章内连接的样式</h1><p>修改的就是我们在文章中写的关于条状的连接.</p>
<p>修改的文件路劲:</p>
<p>themes/next/sources/css/_common/components/post/post.styl  文件;</p>
<p>添加的css 的样式如下:</p>
<pre><code>.post-body p a{
  color: #0593d3;
  border-bottom: none;
 border-bottom: 1px solid #0593d3;
  &amp;:hover {
color: #fc6423;
border-bottom: none;
border-bottom: 1px solid #fc6423;
   }
}
</code></pre><p>注意的是: 这个点不要忘记了.选择.post-body 是为了不影响标题，选择 p 是为了不影响首页“阅读全文”的显示样式.</p>
<h1 id="7-关于Hexo搭建博客的分类"><a href="#7-关于Hexo搭建博客的分类" class="headerlink" title="7.关于Hexo搭建博客的分类"></a>7.关于Hexo搭建博客的分类</h1><p>分类: categories</p>
<p>展示图片:</p>
<p><img src="https://i.imgur.com/Wi2TlZc.png" alt=""></p>
<h2 id="第一步是在主题的配置文件中打开"><a href="#第一步是在主题的配置文件中打开" class="headerlink" title="第一步是在主题的配置文件中打开"></a>第一步是在主题的配置文件中打开</h2><p><img src="https://i.imgur.com/VNPk5Iv.png" alt="打开"></p>
<h2 id="新建对应的page"><a href="#新建对应的page" class="headerlink" title="新建对应的page"></a>新建对应的page</h2><pre><code>hexo new page categories

hexo new page tags
</code></pre><p>之后就是重新的部署;</p>
<p>会在/sources下面生成对应的文件夹,里面对应的是 index.md文件</p>
<h2 id="修改index-md文件"><a href="#修改index-md文件" class="headerlink" title="修改index.md文件"></a>修改index.md文件</h2><p><img src="https://i.imgur.com/JHIVtgl.png" alt=""></p>
<p>我们点击分类的时候会将对应的文件夹里面的index.md文件转化为网页展示出来,我们需要在 index.md中添加的就是类型:</p>
<pre><code>type: categories/tags 
</code></pre><h2 id="在文章中的处理"><a href="#在文章中的处理" class="headerlink" title="在文章中的处理"></a>在文章中的处理</h2><p>对应的我们在新建文章之后需要的是在 顶部设置 tags或者是categories 是什么的类型.</p>
<p>我们在文章中设置的会在进行分类或者是标签归类在一起.</p>
<p>文章的设置展示样例: </p>
<p><img src="https://i.imgur.com/vObeD4f.png" alt=""></p>
<h1 id="8-Hexo之站点地图的搭建sitemap-xml"><a href="#8-Hexo之站点地图的搭建sitemap-xml" class="headerlink" title="8.Hexo之站点地图的搭建sitemap.xml"></a>8.Hexo之站点地图的搭建sitemap.xml</h1><p>也算是第一次接触到站点地图;那么什么是站点地图;</p>
<p>百度走一波: <a href="https://baike.baidu.com/item/%E7%AB%99%E7%82%B9%E5%9C%B0%E5%9B%BE/9991876?fr=aladdin" title="站点地图" target="_blank" rel="noopener">https://baike.baidu.com/item/%E7%AB%99%E7%82%B9%E5%9C%B0%E5%9B%BE/9991876?fr=aladdin</a></p>
<p>自己话语总结一下子站点地图: </p>
<h2 id="在Hexo初始化的位置执行下面的命令"><a href="#在Hexo初始化的位置执行下面的命令" class="headerlink" title="在Hexo初始化的位置执行下面的命令"></a>在Hexo初始化的位置执行下面的命令</h2><p><img src="https://i.imgur.com/S4RYEsQ.png" alt=""></p>
<p>命令如下:</p>
<pre><code>npm install hexo-generator-sitemap --save
</code></pre><p>安装百度的sitemap:</p>
<p><img src="https://i.imgur.com/UHjjl9g.png" alt=""></p>
<h2 id="重新部署点击就可以看到生成的sitemap-xml"><a href="#重新部署点击就可以看到生成的sitemap-xml" class="headerlink" title="重新部署点击就可以看到生成的sitemap.xml"></a>重新部署点击就可以看到生成的sitemap.xml</h2><p><img src="https://i.imgur.com/2SrFsHO.png" alt=""></p>
<h2 id="如果部署后没有显示则在站点配置文件中配置"><a href="#如果部署后没有显示则在站点配置文件中配置" class="headerlink" title="如果部署后没有显示则在站点配置文件中配置"></a>如果部署后没有显示则在站点配置文件中配置</h2><p>站点配置文件中配置:</p>
<pre><code># sitemap
sitemap:
path: sitemap.xml
baidusitemap:
path: baidusitemap.xml
</code></pre><p>学习的连接地址:</p>
<p><a href="http://viggoz.com/2016/05/17/2016-05-17-hexo3/" target="_blank" rel="noopener">http://viggoz.com/2016/05/17/2016-05-17-hexo3/</a></p>
<h2 id="成功生成站点地图文件的展示"><a href="#成功生成站点地图文件的展示" class="headerlink" title="成功生成站点地图文件的展示"></a>成功生成站点地图文件的展示</h2><p><img src="https://i.imgur.com/3mgzbWt.png" alt=""></p>
<p>如上设置,出现,sitemap.xml和baidusitemap.xml 表示站点文件生成.</p>
<h2 id="之后就是百度站点地图的验证"><a href="#之后就是百度站点地图的验证" class="headerlink" title="之后就是百度站点地图的验证"></a>之后就是百度站点地图的验证</h2><p>百度站长平台进行验证: <a href="https://ziyuan.baidu.com/dashboard/index" target="_blank" rel="noopener">https://ziyuan.baidu.com/dashboard/index</a></p>
<p>第一次会输入一些信息,姓名,职位等信息.</p>
<p>后面就是添加站点:</p>
<p><img src="https://i.imgur.com/1mQVvoQ.png" alt=""></p>
<p>之后就是站点属性:</p>
<p>最后就是验证网站.  验证的方式都有详细的说明.</p>
<p><img src="https://i.imgur.com/XKIHybJ.png" alt=""></p>
<p>下载放置到网站的根目录:</p>
<p><img src="https://i.imgur.com/KX28UY5.png" alt=""></p>
<h1 id="9-配置站点地图后出现的hexo-s-命令失效的解决办法"><a href="#9-配置站点地图后出现的hexo-s-命令失效的解决办法" class="headerlink" title="9.配置站点地图后出现的hexo s 命令失效的解决办法"></a>9.配置站点地图后出现的hexo s 命令失效的解决办法</h1><blockquote>
<blockquote>
<p>注意了,我们的是这个服务器上还有一个网站,验证的时候出现自动跳转到那个网页上去,验证失败.<br>而且今天发现我进入 hexo初始化的文件夹里面执行hexo s 的时候出现hexo s 命令不能使用.</p>
</blockquote>
</blockquote>
<p>展示一下子我自己的hexo的版本:</p>
<p><img src="https://i.imgur.com/bEhJgmZ.png" alt=""></p>
<p>问题出现的描述:</p>
<p><img src="https://i.imgur.com/W9Sn05y.png" alt=""></p>
<p>最后查找单独安装了hexo  server ,最后还是老样子,没有解决,看到说在站点的配置文件中不要什么插件的声明,我们想到在设置站点配置文件 的时候出现过对插件的配置.</p>
<p>最后的处理如下: 在站点的配置文件中对插件的声明全部注释掉.</p>
<p>最后完美解决.</p>
<h1 id="10-修改文章后面标签的图标"><a href="#10-修改文章后面标签的图标" class="headerlink" title="10.修改文章后面标签的图标"></a>10.修改文章后面标签的图标</h1><p>原先图标的展示页面:</p>
<p><img src="https://i.imgur.com/gNLvTGj.png" alt=""></p>
<p>修改模板:</p>
<p>在主题下:  themes/next/layout/_macro/post.swig文件:</p>
<p><img src="https://i.imgur.com/nuMWQ8c.png" alt=""></p>
<p>具体的修改位置:</p>
<p><img src="https://i.imgur.com/bneGhKL.png" alt=""></p>
<p>搜索 rel=”tag”&gt;#，将 # 换成<i class="fa fa-tag"></i></p>
<p>最后是修改完成的展示: </p>
<p><img src="https://i.imgur.com/QZhGyct.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> 博客 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo的使用]]></title>
      <url>/2018/01/17/Hexo%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>前言: 一直对hexo的风格所喜欢者,只是在开始的时候选择阴差阳错的选择了workpress ,搭建的博客也是很好使用,最近看到一篇关于hexo搭建的网页,我觉得我还是在来折腾一次,趁着年轻,赶快折腾.</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h1 id="Hexo的安转"><a href="#Hexo的安转" class="headerlink" title="Hexo的安转"></a>Hexo的安转</h1><p>首先是你有自己的云主机; 其次就是你使用软件登录进去,这些我前面都有自己的文件.</p>
<p>我们手下是xshell进行登录:</p>
<h2 id="安转git"><a href="#安转git" class="headerlink" title="安转git"></a>安转git</h2><pre><code>Linux (Ubuntu, Debian)：sudo apt-get install git-core
Linux (Fedora, Red Hat, CentOS)：sudo yum install git-core
</code></pre><p>上面对Linux根据不同使用到的安装git的命令.</p>
<p>之后就是安转nodes</p>
<p>连接地址: (hexo的使用手册)<a href="https://hexo.io/zh-cn/docs/index.html" title="hexo的使用手册" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/index.html</a></p>
<p>根据这个手册在使用的时候出现的信息是不是我所想要的, 执行安转nodes 的第二个命令的时候出现了错误.</p>
<p>其实我们不需要自己输入,直接复制在到xhsell中右击粘贴回车就ok了!</p>
<p>图片一<br><img src="https://i.imgur.com/IoyDaLo.png" alt=""></p>
<p>使用到的命令行如下:</p>
<pre><code>https://hexo.io/zh-cn/docs/index.html

https://hexo.io/zh-cn/docs/index.html
</code></pre><p>之后的操作就是重启连接终端,执行命令进行安转hexo</p>
<p><img src="https://i.imgur.com/JVjeFgU.png" alt=""><br>    nvm install stable</p>
<p>安装Nodes.js之后我们才开始安装Hexo</p>
<p><img src="https://i.imgur.com/laNw1Ai.png" alt=""></p>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>直接复制命令行进行安装:</p>
<pre><code>npm install -g hexo-cli
</code></pre><p>之后就是安装的hexo的初始化等的操</p>
<p><img src="https://i.imgur.com/wh4sJkQ.png" alt=""><br>我们是安装在/opt/hexoflolder文件夹下面.我们使用xftp看看安装完成后的目录结构.<br><img src="https://i.imgur.com/qOs757K.png" alt=""></p>
<p> 使用到的命名行如下:</p>
<pre><code>$ hexo init &lt;folder&gt;
$ cd &lt;folder&gt;
$ npm install
</code></pre><h1 id="第一次安装之后的访问地址"><a href="#第一次安装之后的访问地址" class="headerlink" title="第一次安装之后的访问地址"></a>第一次安装之后的访问地址</h1><p>在这次是我自己的服务器外地址的:</p>
<p>自己服务器的ip地址: 116.196.91.100</p>
<p>我们的访问网址: <a href="http://116.196.91.100:4000/" title="hexo的默认地址" target="_blank" rel="noopener">http://116.196.91.100:4000/</a>  对我们直接访问就可以了!</p>
<p>我们在访问这个地址的时候我们首先要保证的是hexo的服务是不是启动的,启动之后我么 访问才能访问到.</p>
<p><img src="https://i.imgur.com/0A9nG1B.png" alt=""></p>
<p>我们首先要进入的是hexo的root很目录,这里面是blog<br>在输入: hexo s</p>
<p><img src="https://i.imgur.com/uYTzCEU.png" alt=""></p>
<p>访问成功:</p>
<p><img src="https://i.imgur.com/YFFdGir.png" alt=""></p>
<h1 id="按照简书的学习一边再做总结"><a href="#按照简书的学习一边再做总结" class="headerlink" title="按照简书的学习一边再做总结"></a>按照简书的学习一边再做总结</h1><p>新建一个页面(进入到blog根页面) </p>
<pre><code>hexo new &quot;页面的名称&quot;
</code></pre><p>此时会生成一个”页面名称”.md 的文件,地址在:/root/blog/source/_posts</p>
<p>展示如图:</p>
<p><img src="https://i.imgur.com/7s6JBVH.png" alt=""></p>
<p>以后生成的所有的页面都会在这个文件中有对应的md文件.</p>
<p>之后的操作就是使用 hexo generate 生成静态的文件,这个命令的含义是将md文件转化为html文件.</p>
<pre><code>hexo generate 
</code></pre><p><img src="https://i.imgur.com/5C5gpJ3.png" alt=""></p>
<p>之后在blog/public的目录下面会有对应的html. </p>
<p><img src="https://i.imgur.com/cZ95cUA.png" alt=""></p>
<p>2018里面就是刚才的新建的页面你的html.</p>
<p> <strong>展示的结果</strong><br><img src="https://i.imgur.com/NYr1pnO.png" alt=""></p>
<p> 总结: 以后新建页面的时候  使用 的命令分别是</p>
<pre><code>hexo new &quot;post的提交的页面的名称&quot;
</code></pre><p>之后修改里面的内容.</p>
<p>只有生成静态的文件:<br>    hexo generate </p>
<p>之后启动页面 :</p>
<pre><code>hexo s (hexo  server)
</code></pre><h1 id="绑定独立的域名"><a href="#绑定独立的域名" class="headerlink" title="绑定独立的域名"></a>绑定独立的域名</h1><h1 id="安装next主题"><a href="#安装next主题" class="headerlink" title="安装next主题"></a>安装next主题</h1><p><strong>第一步 git pill next主题</strong><br>我们首先进入的是我们的hexo的根目录:(这里是进入 blog)</p>
<pre><code>git clone https://github.com/iissnan/hexo-theme-next themes/next
</code></pre><p>回车,等待完成:</p>
<p><img src="https://i.imgur.com/gEL8KCN.png" alt=""></p>
<p><strong>第二步 配置主题</strong></p>
<p><img src="https://i.imgur.com/MQtU7WR.png" alt=""></p>
<p>修改为next主题</p>
<p><strong>清楚缓冲,并且开启debug服务</strong></p>
<pre><code>hexo clean 
</code></pre><p>开启debug的服务</p>
<pre><code>hexo s --debug
</code></pre><p><img src="https://i.imgur.com/E79lMZE.png" alt=""></p>
<p>ok,不在展示了!</p>
<h1 id="修改主题的scheme"><a href="#修改主题的scheme" class="headerlink" title="修改主题的scheme"></a>修改主题的scheme</h1><blockquote>
<p>注意修改的主题配置文件</p>
</blockquote>
<p>是在根目录下面的 theme文件夹下面  我们打开next目录,之后的我们修改配置文件 下面的scheme </p>
<p><img src="https://i.imgur.com/51OBHhX.png" alt=""></p>
<p><strong>修改主题的文字支持</strong></p>
<p><img src="https://i.imgur.com/eO65ZV3.png" alt=""></p>
<p>注意修改的是站点配置文件</p>
<p>修改的是language:  zh-hans (注意配置文件都需要空一格之后再书写)</p>
<h1 id="出错了-明天解决"><a href="#出错了-明天解决" class="headerlink" title="出错了,明天解决"></a>出错了,明天解决</h1><p>问题的展示:</p>
<p><img src="https://i.imgur.com/ShU33yh.png" alt=""></p>
<p>对于这个问题,我只是修改了站点的配置文件为 语言的设置,还有就是设置的是主题的配置文件,最后重新运行之后出现的错误,</p>
<p>查询之后出现的问题是,在配置文件的时候需要 空一格在书写相应的配置信息.</p>
<p>重新修改配置信息.空格之后开始相应的配置. 重新运行就可以了!</p>
<h1 id="设置主题"><a href="#设置主题" class="headerlink" title="设置主题"></a>设置主题</h1><p> 修改的文件是主题配置文件    </p>
<h1 id="其他的问题"><a href="#其他的问题" class="headerlink" title="其他的问题"></a>其他的问题</h1><p>修改hexo的默认端口,第一个就是在站点配置文件中添加下面的代码:</p>
<pre><code>server:
port: 4001 (自己任意填写)
compress: true
header: true
</code></pre><p>第二个就是直接使用命令行来修改:</p>
<p>进入根目录: hexo server -p(自己喜欢的端口) </p>
<p>之后重新运行,就ok,访问的地址变成: <a href="http://116.196.91.100:40001/" target="_blank" rel="noopener">http://116.196.91.100:40001/</a></p>
<p><strong>后台运行</strong></p>
<p>hexo s &amp;</p>
<p><a href="http://www.tuijiankan.com/2015/05/08/hexo-forever-run/" title="别人的连接" target="_blank" rel="noopener">http://www.tuijiankan.com/2015/05/08/hexo-forever-run/</a></p>
<h1 id="关于hexo的菜单的设置"><a href="#关于hexo的菜单的设置" class="headerlink" title="关于hexo的菜单的设置"></a>关于hexo的菜单的设置</h1><p>菜单的显示如下三部分:</p>
<p> <strong>第一部分是设置菜单的内容</strong></p>
<p>在主题配置文件中:<br>  menu:<br>      home:<br>      about:/about/ ||user  (user表示的就是展示的图标)<br>这里设置的不会显示在页面,而是根据这里的字段去我们在站点配置文件中设置的语音找对应字段去解析出来的文字才是战士的额文字.<br><strong>第二部分解析文字</strong><br>比如我们在我们的站点配置文件中设置的语言是 zh-Hans,之后会在theme这个文件下面的next主题下寻找 zh-Hans.yml去解析 home对应的文字解析,</p>
<p><img src="https://i.imgur.com/ETz0iup.png" alt=""><br><strong>第三部分解析图标</strong><br>menu-icon 表示的就是对于解析的图标.其中 enable 表示的是对图标展示的控制 true 表示的就是显示图标 false表示就是不显示图标</p>
<p><strong> 关于主题的推荐</strong></p>
<p><a href="https://www.zhihu.com/question/24422335" title="主题的推荐" target="_blank" rel="noopener">https://www.zhihu.com/question/24422335</a></p>
<h1 id="next主题的使用文档"><a href="#next主题的使用文档" class="headerlink" title="next主题的使用文档:"></a>next主题的使用文档:</h1><p><a href="http://theme-next.iissnan.com/" title="next的主题使用" target="_blank" rel="noopener">http://theme-next.iissnan.com/</a></p>
<h1 id="傻瓜式安装搭建博客"><a href="#傻瓜式安装搭建博客" class="headerlink" title="傻瓜式安装搭建博客"></a>傻瓜式安装搭建博客</h1><p><a href="https://portablehexo.bitmoe.cn/" title="便携式" target="_blank" rel="noopener">https://portablehexo.bitmoe.cn/</a></p>
<h1 id="关于头像的设置"><a href="#关于头像的设置" class="headerlink" title="关于头像的设置"></a>关于头像的设置</h1><p>修改的主题配置文件  avatar </p>
<p><img src="https://i.imgur.com/EmeWMMs.png" alt=""></p>
<h1 id="创建page"><a href="#创建page" class="headerlink" title="创建page"></a>创建page</h1><p>首先是   进入根目录</p>
<pre><code>hexo new page about 
</code></pre><p>之后就会生成相对应的page页面,这个页面不是文章页面不会显示在页面列表中.</p>
<p>此时会在 resource目录下生成about 文件,并且生成index.md文件</p>
<p>部署就行了.</p>
<h1 id="记录一下子自己的配置的"><a href="#记录一下子自己的配置的" class="headerlink" title="记录一下子自己的配置的"></a>记录一下子自己的配置的</h1><p><img src="https://i.imgur.com/6WbGPda.png" alt=""></p>
<p>图片有几点需要在此记录一下子.</p>
<p>首先是图片这个菜单项的添加和初见这个页面文字的居中展示和分类标签的设置.</p>
<p><img src="https://i.imgur.com/kaXsuz7.png" alt=""></p>
<p><strong>一个就是菜单的图片的显示</strong></p>
<p> 说明一下子,我使用的主题是 next 主题.</p>
<p>其他的站点配置不需要更改,我们需要的是修改主题页面 下的_config.yml配置文件.</p>
<p> 在menu 下面 添加photo: /categories/图片</p>
<p>然后在主题的lauguage目录下找到你在站点配置文件下面设置的站点的语言信息,比如我在我的站点的语言配置的是zh-Hans ,在next主题下面的languange文件夹下面寻找到 zh-Hans.yml 在里面添加解析字段:<br><img src="https://i.imgur.com/jsiQAjR.png" alt=""></p>
<p>主题文档的文字解析:</p>
<p><img src="https://i.imgur.com/6nf0Gs0.png" alt=""></p>
<p>你们看到我在menu下面添加的 photo: 图片   </p>
<blockquote>
<p>注意的是在设置配置的时候 需要的而是空一格在填写.</p>
</blockquote>
<p>我们在看一个图片:</p>
<p><img src="https://i.imgur.com/qs6FZvo.png" alt=""></p>
<p>这个是我们新建文章的时候 layout的类型,默认是post类型:</p>
<p>page.md是页面,会在sources下面创建对应的文件夹,生成index.md文件.</p>
<p>draf.md 是我们文章的草稿就是这个类型.</p>
<p>新建photo.md类型,里面的格式如下:</p>
<p><img src="https://i.imgur.com/oQwdcvb.png" alt=""></p>
<p>新建一个文章  hexo new layout phot “初见”</p>
<p>关键点就是在这个文章md中添加: categories: 图片</p>
<blockquote>
<p>试试直接新建一个页面 不适用photo 只是添加分类为图片,我们看看<br>最后测试,只要设置了 categories: 图片 都会分类到图片这个菜单下.</p>
</blockquote>
<p><strong>配置文字居中显示</strong><br>学习连接:</p>
<p><a href="https://hexo.io/zh-cn/docs/tag-plugins.html" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/tag-plugins.html</a></p>
<p>文字居中两种使用:</p>
<ol>
<li>HTML方式: 给img添加属性 class=”blockquote-center”</li>
<li>标签的方式使用  : 使用的标签是 centerquote或者是 cq</li>
</ol>
<p>使用样例:</p>
<pre><code>&lt;!-- 标签 方式，要求版本在0.4.5或以上 --&gt;
{% centerquote %}blah blah blah{% endcenterquote %}

&lt;!-- 标签别名 --&gt;
{% cq %} blah blah blah {% endcq %}
</code></pre><p><strong>突破容器宽度限制的图片</strong></p>
<p>作用: 图片自动扩大26%,并突破文章容器的宽度.<br>使用的方式两种: </p>
<ol>
<li>HTML 使用  添加 class=”full-image”</li>
<li><p>标签的使用方式: </p>
 <!-- HTML方式: 直接在 Markdown 文件中编写 HTML 来调用 -->
 <!-- 其中 class="full-image" 是必须的 -->
<p> <img src="/image-url" class="full-image"></p>
 <!-- 标签 方式，要求版本在0.4.5或以上 -->
 <span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/image-url" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
 <!-- 别名 -->
 <span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/image-url" class="full-image" alt="alt" title="title"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
</li>
</ol>
<blockquote>
<blockquote>
<p> 我习惯是在md文件中直接引用图片的文件,这样设置我们成功.</p>
</blockquote>
</blockquote>
<h1 id="开启评论功能"><a href="#开启评论功能" class="headerlink" title="开启评论功能"></a>开启评论功能</h1><p>文章的md的开头:</p>
<p>开启评论的设置</p>
<p>comments  设置为true 就可以了!</p>
<p>设置阅读更多的操作:</p>
<p>方式有三种:</p>
<ol>
<li>第一种是使用 <!--more--> 之歌标志之前的会作为简介来展现,出现点击阅读全文的字样.</li>
<li>在文章的 front-matter(hexo中–之间的的文字描述—) 中添加description,,,,,,具体的格式是如下:  <code>description: 这是我要展示的简介文字</code></li>
<li><p>第三个就是 配置主题文件的配置文件 </p>
<p> auto_excerpt”<br>   enable: true<br>   length: 150(表示截取的长度是150字符,也是默认的)</p>
</li>
</ol>
<h1 id="最后关于tags和categories"><a href="#最后关于tags和categories" class="headerlink" title="最后关于tags和categories"></a>最后关于tags和categories</h1><p>首先是tags 是会展示在文章的最后的  开头是#区别</p>
<p>categories是分类,展示在文档的首页.</p>
]]></content>
      
        <categories>
            
            <category> 博客 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2018/01/17/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.<br><a id="more"></a></p>
<h1 id="关于迟到"><a href="#关于迟到" class="headerlink" title="关于迟到"></a>关于迟到</h1><p>迟到后的心理:</p>
<p>朋友圈的图片展示: </p>
<p>迟到后的处理: 及时是迟到了,不做别的,尽量早点赶到.</p>
<p>还有就是已经迟到了,无所谓了,吃个早餐慢慢的到达,反正是迟到了!</p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[初见]]></title>
      <url>/2018/01/11/%E5%88%9D%E8%A7%81/</url>
      <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>图片的展示区域:</p>
</blockquote>
<p>只是展示:<br><a id="more"></a><br><blockquote class="blockquote-center"><p>图片壁纸: </p>
</blockquote></p>
<p><img src="https://i.imgur.com/g0bkrfu.jpg" alt=""></p>
<p><img src="https://i.imgur.com/dGvwrkA.jpg" alt=""></p>
<p><img src="https://i.imgur.com/ZVOdM0E.jpg" alt=""></p>
<p><img src="https://i.imgur.com/sl6HByx.jpg" alt=""></p>
<p><img src="https://i.imgur.com/p048ZtX.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> 图片 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图片 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[测试页面]]></title>
      <url>/2018/01/10/%E6%B5%8B%E8%AF%95%E9%A1%B5%E9%9D%A2/</url>
      <content type="html"><![CDATA[<h1 id="TCP-UDP编程"><a href="#TCP-UDP编程" class="headerlink" title="TCP/UDP编程"></a>TCP/UDP编程</h1><p>在最近的无线模组的开发中对于TCP和UDP的协议的要求有了进一步的需求,这片博客是自己学习基础的一片博客,用于自己以后在学习过程中的查看和基础回顾.话说最近是不是该歇一歇面试的知识点整理了!<br><a id="more"></a></p>
<h2 id="基础知识点详解"><a href="#基础知识点详解" class="headerlink" title="基础知识点详解:"></a>基础知识点详解:</h2><h4 id="第一个基础知识就是OSI模型的展示"><a href="#第一个基础知识就是OSI模型的展示" class="headerlink" title="第一个基础知识就是OSI模型的展示:"></a>第一个基础知识就是OSI模型的展示:</h4><p>osi一直在说,今天来看看osi(open System Interconncetion,OSI/RM,Open System Interconnection Reference Modle):</p>
<p>OSI模型，即开放式通信系统互联参考模型(Open System Interconnection,OSI/RM,Open Systems Interconnection Reference Model)，是国际标准化组织(ISO)提出的一个试图使各种计算机在世界范围内互连为网络的标准框架，简称OSI。</p>
<p>注意这几个缩写 ios(苹果公司的移动操作系统); iso(国际标准化组织) OSI(osi模型)</p>
<p>OSI将计算机网络体系结构(architecture）划分为以下七层;这也就是我们常说的osi七层协议:</p>
<p><img src="http://i.imgur.com/J41QDKB.jpg" alt=""></p>
<h4 id="下面的是百度百科关于各层的说明-通俗易懂"><a href="#下面的是百度百科关于各层的说明-通俗易懂" class="headerlink" title="下面的是百度百科关于各层的说明(通俗易懂)"></a>下面的是百度百科关于各层的说明(通俗易懂)</h4><ul>
<li>物理层(Physical Layer): 将数据转换为可通过物理介质传送的电子信号 相当于邮局中的搬运工人</li>
</ul>
<ul>
<li>数据链路层(Datalink Layer): 决定访问网络介质的方式在此层将数据分帧，并处理流控制。本层指定拓扑结构并提供硬件寻址。相当于邮局中的装拆箱工人</li>
</ul>
<ul>
<li>网络层(Network Layer): 使用权数据路由经过大型网络 相当于邮局中的排序工人(ip协议)</li>
</ul>
<ul>
<li>传输层(Transport Layer): 提供终端到终端的可靠连接 相当于公司中跑邮局的送信职员</li>
</ul>
<ul>
<li>会话层(Session Layer): 允许用户使用简单易记的名称建立连接 相当于公司中收寄信、写信封与拆信封的秘书</li>
</ul>
<ul>
<li>表示层(Presentation Layer): 协商数据交换格式 相当公司中简报老板、替老板写信的助理</li>
</ul>
<ul>
<li>应用层(Appliication Layer): 用户的应用程序和网络之间的接口老板</li>
</ul>
<h4 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h4><p>数据包的概念: 数据包是一个信息单位，作为一个整体，从网络中的一个设备传送给另一个设备。</p>
<p>数据包是在应用层创建的,从上向下一层一层的传递,每一层对数据包重新的组装.</p>
<p>数据包的格式:</p>
<ol>
<li>数据包结构</li>
</ol>
<p>数据包包含了几种不同类型的数据：</p>
<ul>
<li>信息，某种类的计算机控制数据和命令<br>-</li>
<li><p>会话控制代码</p>
</li>
<li><p>数据包头</p>
</li>
<li><p>数据</p>
</li>
<li><p>报尾</p>
</li>
</ul>
<ol>
<li>创建数据包</li>
</ol>
<p>数据包的创建过程是从OSI模型的应用层开始的。跨网络传输的信息要从应用层开始，往下依次穿过各层。每层都对数据包进行重新组装，以增加自己的信息（信头）。</p>
<h4 id="TCP-UDP的缩写-在传输层上-第四层"><a href="#TCP-UDP的缩写-在传输层上-第四层" class="headerlink" title="TCP/UDP的缩写(在传输层上(第四层))"></a>TCP/UDP的缩写(在传输层上(第四层))</h4><p>TCP(Transmission Control Protocol，传输控制协议）:</p>
<p>UDP( User Datagram Protocol 用户数据报协议)，在网络中它与TCP协议一样用于处理数据包。在OSI模型中，在第四层——传输层，处于IP协议的上一层。</p>
<p>IP协议: IP (Internet Protocol),处于网络层上(第三层)</p>
<p><strong>网络层:</strong></p>
<p>网络层负责对子网间的数据包进行路由选择。网络层还可以实现拥塞控制、网际互连等功能。</p>
<p><strong>在这一层，数据的单位称为数据包（packet）。网络层协议的代表包括：IP、IPX、RIP、OSPF、ARP、RARP、ICMP、IGMP等。</strong></p>
<p><strong>传输层:</strong></p>
<p>传输层是第一个端到端，即主机到主机的层次。传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输。此外，传输层还要处理端到端的差错控制和流量控制问题。</p>
<p><strong>在这一层，数据的单位称为数据段（segment）。传输层协议的代表包括：TCP、UDP、SPX等。</strong></p>
<p><strong>应用层:</strong></p>
<p><strong>应用层为操作系统或网络应用程序提供访问网络服务的接口。应用层协议的代表包括：Telnet、FTP、HTTP、SNMP等。</strong></p>
<p>##什么是TCP和UDP ##</p>
<p>TCP和UDP协议的区别(面试中经常问到):</p>
<ul>
<li>UDP<ul>
<li>面向无连接，数据不安全，速度快。不区分客户端与服务端。</li>
</ul>
</li>
<li>TCP<br>　　* 面向连接（三次握手），数据安全，速度略低。分为客户端和服务端。<ul>
<li>三次握手: 客户端先向服务端发起请求, 服务端响应请求, 传输数据</li>
</ul>
</li>
</ul>
<p>在这里在说说sockect(套接字)</p>
<ul>
<li>网络上具有唯一标识的IP地址和端口号组合在一起才能构成唯一能识别的标识符套接字。<ul>
<li>通信的两端都有Socket。</li>
<li>网络通信其实就是Socket间的通信。</li>
<li>数据在两个Socket间通过IO流传输。</li>
<li>Socket在应用程序中创建，通过一种绑定机制与驱动程序建立关系，告诉自己所对应的IP和port。</li>
</ul>
</li>
</ul>
<h2 id="UDP传输"><a href="#UDP传输" class="headerlink" title="UDP传输"></a>UDP传输</h2><p><strong>DatagramSocket类用来创建和发送UDP的Socket实例;</strong></p>
<p>DatagramSocket()：创建实例。通常用于客户端编程，它并没有特定监听的端口，仅仅使用一个临时的。</p>
<p>DatagramSocket(int port)：创建实例，并固定监听Port端口的报文。 </p>
<p>DatagramSocket(int port, InetAddress localAddr)：这是个非常有用的构建器，当一台机器拥有多于一个IP地址的时候，由它创建的实例仅仅接收来自LocalAddr的报文</p>
<p>receive(DatagramPacket d)：接收数据报文到d中。receive方法产生一个“阻塞”。 </p>
<p>send(DatagramPacket d)：发送报文d到目的地。</p>
<p>setSoTimeout(int timeout)：设置超时时间，单位为毫秒。</p>
<p>close()：关闭DatagramSocket。在应用程序退出的时候，通常会主动释放资源，关闭Socket，但是由于异常地退出可能造成资源无法回收。所以，应该在程序完成时，主动使用此方法关闭Socket，或在捕获到异常抛出后关闭Sock</p>
<p><strong>DatagramPacket：用于处理报文，将byte数组、目标地址、目标端口等数据包装成报文或者将报文拆卸成byte数组。</strong></p>
<p>DatagramPacket(byte[] buf, int length, InetAddress addr, int port)：从buf数组中，取出length长的数据创建数据包对象，目标是addr地址，port端口。 </p>
<p>DatagramPacket(byte[] buf, int offset, int length, InetAddress address, int port)：从buf数组中，取出offset开始的、length长的数据创建数据包对象，目标是addr地址，port端口。 </p>
<p>DatagramPacket(byte[] buf, int offset, int length)：将数据包中从offset开始、length长的数据装进buf数组。</p>
<p>DatagramPacket(byte[] buf, int length)：将数据包中length长的数据装进buf数组。 </p>
<p>getData()：它从实例中取得报文的byte数组编码。 </p>
<ul>
<li>1.发送Send<ul>
<li>创建DatagramSocket, 随机端口号</li>
<li>创建DatagramPacket, 指定数据, 长度, 地址, 端口</li>
<li>使用DatagramSocket发送DatagramPacket</li>
<li>关闭DatagramSocket</li>
</ul>
</li>
<li>2.接收Receive<ul>
<li>创建DatagramSocket, 指定端口号</li>
<li>创建DatagramPacket, 指定数组, 长度</li>
<li>使用DatagramSocket接收DatagramPacket</li>
<li>关闭DatagramSocket</li>
<li>从DatagramPacket中获取数据</li>
</ul>
</li>
<li>3.接收方获取ip和端口号<ul>
<li>String ip = packet.getAddress().getHostAddress();</li>
<li>int port = packet.getPort();</li>
</ul>
</li>
</ul>
<p>发送端的java代码:</p>
<pre><code>package com.heima.socket;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.SocketException;
import java.net.UnknownHostException;
public class Demo1_Send {
/**
 * * 1.发送Send
 * 创建DatagramSocket, 随机端口号
 * 创建DatagramPacket, 指定数据, 长度, 地址, 端口
 * 使用DatagramSocket发送DatagramPacket
 * 关闭DatagramSocket
 * @throws SocketException 
 * @throws UnknownHostException 
 */
public static void main(String[] args) throws Exception {
    String str = &quot;what are you 弄啥呢?&quot;;
    DatagramSocket socket = new DatagramSocket();                //创建Socket相当于创建码头
    //InetAddress.getByName(&quot;127.0.0.1&quot;):要发给谁,要写对方的ip地址
    DatagramPacket packet =                                     //创建Packet相当于集装箱,,存放要发送的数据
            new DatagramPacket(str.getBytes(), str.getBytes().length, InetAddress.getByName(&quot;127.0.0.1&quot;), 6666);
    socket.send(packet);                                        //发货,将数据发出去
    socket.close();                                                //关闭码头
}
}
</code></pre><p>UDP传输的接收端:</p>
<pre><code>package com.heima.socket;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.SocketException;
public class Demo1_Receive {
/**
 ** 2.接收Receive
 * 创建DatagramSocket, 指定端口号
 * 创建DatagramPacket, 指定数组, 长度
 * 使用DatagramSocket接收DatagramPacket
 * 关闭DatagramSocket
 * 从DatagramPacket中获取数据
 * @throws Exception 
 */
public static void main(String[] args) throws Exception {
    DatagramSocket socket = new DatagramSocket(6666);        //创建Socket相当于创建码头
    DatagramPacket packet = new DatagramPacket(new byte[1024], 1024);//创建Packet相当于创建集装箱
    socket.receive(packet);                                    //接货,接收数据

    byte[] arr = packet.getData();                            //获取数据
    int len = packet.getLength();                            //获取有效的字节个数
    System.out.println(new String(arr,0,len));
    socket.close();
}
}
</code></pre><p>对上面的代码进行优化:</p>
<p>发送端优化代码展示:</p>
<pre><code>package com.heima.socket;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.SocketException;
import java.net.UnknownHostException;
import java.util.Scanner;
public class Demo2_Send {
/**
 * * 1.发送Send
 * 创建DatagramSocket, 随机端口号
 * 创建DatagramPacket, 指定数据, 长度, 地址, 端口
 * 使用DatagramSocket发送DatagramPacket
 * 关闭DatagramSocket
 * @throws SocketException 
 * @throws UnknownHostException 
 */
public static void main(String[] args) throws Exception {
    Scanner sc = new Scanner(System.in);                        //创建键盘录入对象
    DatagramSocket socket = new DatagramSocket();                //创建Socket相当于创建码头

    while(true) {
        String line = sc.nextLine();                            //获取键盘录入的字符串
        if(&quot;quit&quot;.equals(line)) {
            break;
        }
        DatagramPacket packet =                                 //创建Packet相当于集装箱
                new DatagramPacket(line.getBytes(), line.getBytes().length, InetAddress.getByName(&quot;127.0.0.1&quot;), 6666);
        socket.send(packet);                                    //发货,将数据发出去
    }
    socket.close();                                                //关闭码头
}
}
</code></pre><p>接收端代码优化展示:</p>
<pre><code>package com.heima.socket;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.SocketException;
public class Demo2_Receive {
/**
 ** 2.接收Receive
 * 创建DatagramSocket, 指定端口号
 * 创建DatagramPacket, 指定数组, 长度
 * 使用DatagramSocket接收DatagramPacket
 * 关闭DatagramSocket
 * 从DatagramPacket中获取数据
 * @throws Exception 
 */
public static void main(String[] args) throws Exception {
    DatagramSocket socket = new DatagramSocket(6666);        //创建Socket相当于创建码头
    DatagramPacket packet = new DatagramPacket(new byte[1024], 1024);//创建Packet相当于创建集装箱

    while(true) {
        socket.receive(packet);                                    //接货,接收数据

        byte[] arr = packet.getData();                            //获取数据
        int len = packet.getLength();                            //获取有效的字节个数
        String ip = packet.getAddress().getHostAddress();        //获取ip地址
        int port = packet.getPort();                            //获取端口号
        System.out.println(ip + &quot;:&quot; + port + &quot;:&quot; + new String(arr,0,len));
    }
}
}
</code></pre>]]></content>
      
        <categories>
            
            <category> 博客 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[frist]]></title>
      <url>/2018/01/10/frist/</url>
      <content type="html"><![CDATA[<h1 id="执行一任务中Activity的解析"><a href="#执行一任务中Activity的解析" class="headerlink" title="执行一任务中Activity的解析"></a>执行一任务中Activity的解析</h1><p>告诉自己每天认真的学习,充电!过好每一天.</p>
<a id="more"></a>
<p> 我们执行异步任务的类是: EsptouchDemoActivity</p>
<pre><code>new EsptouchAsyncTask3().execute(apSsid, apBssid, apPassword,
isSsidHiddenStr, taskResultCountStr); // 参数  apssid apbssid appassword no 1;
</code></pre><h2 id="开始分析这个异步任务"><a href="#开始分析这个异步任务" class="headerlink" title="开始分析这个异步任务"></a>开始分析这个异步任务</h2><p>参数说明,是哪个参数分别是在doInBackground中使用到的, 和设置进度条使用到的,  最后是在onPostExecuter中使用到的,是一个集合;</p>
<p>我们看看这个接口 : IEsptouchResult 里面有四个方法:第一个方法是 是否继续进行下一步    第二个方法是检查这个任务是不是用户自己关闭的; 第三个方法是: 获取设备的bssid 第四个方法是获取设备的 ip地址.</p>
<pre><code>private class EsptouchAsyncTask3 extends AsyncTask&lt;String, Void, List&lt;IEsptouchResult&gt;&gt; {

    private ProgressDialog mProgressDialog;

    private IEsptouchTask mEsptouchTask;

    private final Object mLock = new Object();

    @Override  
    protected void onPreExecute() {  //  准备工作
    异步任务的第一个方法,其实就是展示对话框,直接不看,有一点就是有队task的是不是空的判断,非空直接打断
    }



    @Override  // 异步任务的最后返回的结果    没什么可看的,最重要的在上面

    protected void onPostExecute(List&lt;IEsptouchResult&gt; result) {

        IEsptouchResult firstResult = result.get(0);
        Log.d(TAG, &quot;onPostExecute: &quot;);

        if (!firstResult.isCancelled()) {// isCancelled 表示是不是客户关闭的  这里不是客户关闭的
//                int count = 0; 
//                final int maxDisplayCount = 5; 
            if (firstResult.isSuc()) {
                   try {  
                          if(str_ssid_FLAG.equals(str_ssid)){ // 
                              if(!str_pass_FLAG.equals(str_pass)){  // dubug不走
                                  if(str_ssid.length()&gt;0 &amp;&amp; str_pass.length()&gt;0 &amp;&amp; index!=-1){
                                      ssid_list.set(index, str_ssid);
                                      pass_list.set(index, str_pass);
                                      writeSSID(FAVOSSIDPATH);
                                      writePASS(FAVOPASSPATH);
                                  }
                              }
                          }else{
                              if(str_ssid.length()&gt;0 &amp;&amp; str_pass.length()&gt;0){
                                  ssid_list.add(str_ssid);
                                  pass_list.add(str_pass);
                                  writeSSID(FAVOSSIDPATH);
                                  writePASS(FAVOPASSPATH);
                              }
                          }
                    } catch (Exception e) {  
                        // TODO Auto-generated catch block  
                        e.printStackTrace();  
                    } 
                  new AlertDialog.Builder(EsptouchDemoActivity.this)
                  .setIcon(android.R.drawable.ic_dialog_info)
                  .setTitle(&quot;提示&quot;)
                  .setMessage(&quot;配置成功!&quot;) 
                  .setPositiveButton(&quot;确定&quot;, new DialogInterface.OnClickListener() {
                      public void onClick(DialogInterface dialog, int whichButton) {

                            dialog.dismiss();    
                            finish();
                      }
                  }).show();  
            } else { 

                 str_ssid = null;
                 str_pass = null;

                  new AlertDialog.Builder(EsptouchDemoActivity.this)
                  .setIcon(android.R.drawable.ic_dialog_info)
                  .setTitle(&quot;提示&quot;)
                  .setMessage(&quot;配置失败，请重试!&quot;) 
                  .setPositiveButton(&quot;确定&quot;, new DialogInterface.OnClickListener() {
                      public void onClick(DialogInterface dialog, int whichButton) {
                            dialog.dismiss();     
                      }
                  }).show();
            }
        }
    }
}
</code></pre><p>上面的是准备的方法和最后的返回的方法; 我们单独将 doInBackground 分出来设置一下子</p>
<pre><code>@Override // 关键方法
    protected List&lt;IEsptouchResult&gt; doInBackground(String... params) {

        int taskResultCount = -1;  //  初始化默认的值  最后赋值为1
        synchronized (mLock) { 

            // 获取传递过来的参数
            String apSsid = params[0]; //  ssid
            String apBssid = params[1]; //  bssid
            String apPassword = params[2]; // 密码
            String isSsidHiddenStr = params[3]; //  no
            String taskResultCountStr = params[4]; // 1
            boolean isSsidHidden = false;

            if (isSsidHiddenStr.equals(&quot;YES&quot;)) {  //  不会执行
                isSsidHidden = true;
            }
            taskResultCount = Integer.parseInt(taskResultCountStr); //1  实质就是讲转化的string 转化为int  结果就是我们选择的1

            mEsptouchTask = new EsptouchTask(apSsid, apBssid, apPassword,  //传递参数
                    isSsidHidden, EsptouchDemoActivity.this);

            mEsptouchTask.setEsptouchListener(myListener); //  这是参数类型  IEsptouchListener 这个接口里面只有一个方法就是添加 IEsptouchResult的方法;
        }


        List&lt;IEsptouchResult&gt; resultList = mEsptouchTask.executeForResults(taskResultCount);   //



        return resultList;
    }
</code></pre><p>我们看到首先是将参数传递到EsptouchTask中:</p>
<pre><code>public EsptouchTask(String apSsid, String apBssid, String apPassword,
        boolean isSsidHidden, Context context) {

    _mParameter = new EsptouchTaskParameter();
    _mEsptouchTask = new __EsptouchTask(apSsid, apBssid, apPassword,
            context, _mParameter, isSsidHidden);
}
</code></pre><p>EsptouchTaskParameter我们看过,里面定义了很多的常量和方法,不细看了<br>再一次将参数传递过去__EsptouchTask:</p>
<pre><code>public __EsptouchTask(String apSsid, String apBssid, String apPassword,
        Context context, IEsptouchTaskParameter parameter,
        boolean isSsidHidden) {
    // 空处理不看了   接下来就是成员变量接收传递过来的信息
    mContext = context;
    mApSsid = apSsid;
    mApBssid = apBssid;
    mApPassword = apPassword;

    mIsCancelled = new AtomicBoolean(false);  //  多线程高并发使用的饿一个类  比较和赋值一体化

    mSocketClient = new UDPSocketClient();  //  具有发送 DatagramPacket的方法

    mParameter = parameter;  //  获取定义好的数据类型的值

    mSocketServer = new UDPSocketServer(mParameter.getPortListening(),  //  获取端口监听   超时时间   上下文
            mParameter.getWaitUdpTotalMillisecond(), context);

    mIsSsidHidden = isSsidHidden; // false

    mEsptouchResultList = new ArrayList&lt;IEsptouchResult&gt;(); // 创建一个存放IEsptouchResult的集合
mBssidTaskSucCountMap = new HashMap&lt;String, Integer&gt;();  // 创建集合 来干嘛的  关于ssid的task 进行数量的一个集合
}
</code></pre><p>我们继续查看: new AtomicBoolean(false); 传递的是一个false 实际测试的结果也是false;接下来是一个实例化了一 UDPSocketClient</p>
<p>我们看看坐的是什么操作:</p>
<pre><code>public UDPSocketClient() {
    try {
        this.mSocket = new DatagramSocket();  //  用于接收的发送udp的sockect的实例
        this.mIsStop = false;
        this.mIsClosed = false;
    } catch (SocketException e) {
        if (__IEsptouchTask.DEBUG) {   // 日志管理  是true 
            Log.e(TAG, &quot;SocketException&quot;);
        }
        e.printStackTrace();
    }
}
</code></pre><p>我们可以看出来,在实际的过程中,创建udp通信实例中,初始化了数据包.我们继续,获取的参数parameter,以成员变量保存,下面一个是我们看到udpsockectServer ,将获取到的监听端口传递进去; 监听端口是18266  设置超时的时间是60000 ,一个上下文</p>
<h2 id="关于UDPSocketServer"><a href="#关于UDPSocketServer" class="headerlink" title="关于UDPSocketServer"></a>关于UDPSocketServer</h2><p>代码如下:</p>
<pre><code>public UDPSocketServer(int port, int socketTimeout, Context context) { //  第一个是我们需要监听的端口 18266,  超时时间,  山下文
    this.mContext = context;
    this.buffer = new byte[64];
    this.mReceivePacket = new DatagramPacket(buffer, 64);  //  接收DatagramSockect
    try {
        this.mServerSocket = new DatagramSocket(port);
        this.mServerSocket.setSoTimeout(socketTimeout);
        this.mIsClosed = false;

        //  获取Android的wifi管理
        WifiManager manager = (WifiManager) mContext
                .getSystemService(Context.WIFI_SERVICE);

        mLock = manager.createMulticastLock(&quot;test wifi&quot;);  //  创建组播锁   输入的&quot;test wifi 是一个tag&quot;   最后会调用acquire
        Log.d(TAG, &quot;mServerSocket is created, socket read timeout: &quot;
                + socketTimeout + &quot;, port: &quot; + port);
    } catch (IOException e) {
        Log.e(TAG, &quot;IOException&quot;);
        e.printStackTrace();
    }
}
</code></pre><p>我们在doInbackground中看到传递一个myListener,我们看看最后传递到哪里了!参数的类型如下:</p>
<p>// myListener的类型是一个接口: 接口IEsptouchListener  只有一个方法那就是 添加onEsptouchResultAdded()方法;添加的参数类型IEsptouchResul(四个方法是关于设备的,监听回调)</p>
<p>第一将这个监听回调对象传递到 EsptouchTsak类中: 具体代码如下:</p>
<pre><code>@Override
public void setEsptouchListener(IEsptouchListener esptouchListener) {
    _mEsptouchTask.setEsptouchListener(esptouchListener);
}
</code></pre><p>我们可以看到类型不变,只不过传递到_mEsptouchTask,我们继续查看:</p>
<p>_mEsptouchTask类中:</p>
<pre><code>@Override
public void setEsptouchListener(IEsptouchListener esptouchListener) {
    mEsptouchListener = esptouchListener;
}
</code></pre><p>最后也就是在_mEsptouchTask类中接收了, 成员变量来保存.</p>
<h2 id="最后我们看看-关键方法"><a href="#最后我们看看-关键方法" class="headerlink" title="最后我们看看 关键方法"></a>最后我们看看 关键方法</h2><pre><code>List&lt;IEsptouchResult&gt; resultList = mEsptouchTask.executeForResults(taskResultCount);   //默认是1,可以在下拉刷新中选择
</code></pre><p>继续在EsptouchTask中查找这个方法</p>
<pre><code>public List&lt;IEsptouchResult&gt; executeForResults(int expectTaskResultCount) //传递过来是1 默认是1可以选择
        throws RuntimeException {
    if (expectTaskResultCount &lt;= 0) {
        expectTaskResultCount = Integer.MAX_VALUE;
    }
    return _mEsptouchTask.executeForResults(expectTaskResultCount); // 再次传递执行
}
</code></pre><p>同理也就是传递到 _mEsptouchTask中去,我们继续查看</p>
<p>/**</p>
<pre><code>*  4  追查的结果  _mEsptouchTask.executeForResults(expectTaskResultCount); //  传递的是1
* // 关键方法
@Override
public List&lt;IEsptouchResult&gt; executeForResults(int expectTaskResultCount)throws RuntimeException {

__checkTaskValid(); //  判断esptouchtask只能执行一次  不需要看

mParameter.setExpectTaskResultCount(expectTaskResultCount);

// udp 通信中获取 up地址  ESPnETTYIL工具类

InetAddress localInetAddress = EspNetUtil.getLocalInetAddress(mContext);  //  结果是获取手机的IP地址  192.168.188.23

// generator the esptouch byte[][] to be transformed, which will cost
// some time(maybe a bit much)
IEsptouchGenerator generator = new EsptouchGenerator(mApSsid, mApBssid, mApPassword, localInetAddress, mIsSsidHidden);

// listen the esptouch result asyn

__listenAsyn(mParameter.getEsptouchResultTotalLen());   实质就是 _listenAsyn(11);

boolean isSuc = false;
for (int i = 0; i &lt; mParameter.getTotalRepeatTime(); i++) {    //mParameter.getTotalRepeatTime()=1;

isSuc = __execute(generator);  //  这个方法中会去发送数据包

if (isSuc) {

return __getEsptouchResultList();

}
}

if (!mIsInterrupt) {
// wait the udp response without sending udp broadcast
try {
Thread.sleep(mParameter.getWaitUdpReceivingMillisecond());
} catch (InterruptedException e) {
// receive the udp broadcast or the user interrupt the task

if (this.mIsSuc) {

return __getEsptouchResultList();

} else {

this.__interrupt();

return __getEsptouchResultList();
}
}
this.__interrupt();
}

return __getEsptouchResultList();

}

*/
</code></pre><h2 id="我们首先看第一个关键性的方法"><a href="#我们首先看第一个关键性的方法" class="headerlink" title="我们首先看第一个关键性的方法"></a>我们首先看第一个关键性的方法</h2><p>有一个小的操作需要看看  mParameter.setExpectTaskResultCount(expectTaskResultCount);</p>
<p>@Override<br>    public int getExpectTaskResultCount() {<br>        return this.mExpectTaskResultCount;<br>    }</p>
<pre><code>@Override
public void setExpectTaskResultCount(int expectTaskResultCount) {
    this.mExpectTaskResultCount = expectTaskResultCount;
}
</code></pre><p>我们看看又初始化了一个类:localInetAddress这个是获取手机的IP地址 这里就是192.168.188.23</p>
<p> IEsptouchGenerator generator = new EsptouchGenerator(mApSsid, mApBssid, mApPassword, localInetAddress, mIsSsidHidden);</p>
<p>我们看看初始化的时候的操作:</p>
<pre><code>public EsptouchGenerator(String apSsid, String apBssid, String apPassword,
        InetAddress inetAddress, boolean isSsidHiden) { // ssid bssid pwd 192.168.188.23, false 
    // generate guide code

    GuideCode gc = new GuideCode();
    char[] gcU81 = gc.getU8s();
    mGcBytes2 = new byte[gcU81.length][];

    for (int i = 0; i &lt; mGcBytes2.length; i++) {
        mGcBytes2[i] = ByteUtil.genSpecBytes(gcU81[i]); //看看这个数据装的是什么
    }

    // generate data code
    DatumCode dc = new DatumCode(apSsid, apBssid, apPassword, inetAddress,
            isSsidHiden);
    char[] dcU81 = dc.getU8s();
    mDcBytes2 = new byte[dcU81.length][];

    for (int i = 0; i &lt; mDcBytes2.length; i++) {
        mDcBytes2[i] = ByteUtil.genSpecBytes(dcU81[i]);  //看看这个数据装的是什么
    }

}
</code></pre><p>我们debug打印一下子就OK了!</p>
<p>gcU81:四个元素: </p>
<p>mGcBytes2:</p>
<p>DatumCode:</p>
<p>mDcBytes2:</p>
<p>直接图片展示: <img src="http://i.imgur.com/k7gL7G9.png" alt=""></p>
<p>下面的都是关于 DatumCode的构造方法:</p>
<p>  public DatumCode(String apSsid, String apBssid, String apPassword,<br>            InetAddress ipAddress, boolean isSsidHiden) {  // 构造方法<br>        // Data = total len(1 byte) + apPwd len(1 byte) + SSID CRC(1 byte) +<br>        // BSSID CRC(1 byte) + TOTAL XOR(1 byte)+ ipAddress(4 byte) + apPwd + apSsid apPwdLen &lt;=<br>        // 105 at the moment</p>
<pre><code>    // total xor
    char totalXor = 0;

    char apPwdLen = (char) ByteUtil.getBytesByString(apPassword).length;

    CRC8 crc = new CRC8();
    crc.update(ByteUtil.getBytesByString(apSsid));
    char apSsidCrc = (char) crc.getValue();

    crc.reset();
    crc.update(EspNetUtil.parseBssid2bytes(apBssid));
    char apBssidCrc = (char) crc.getValue();

    char apSsidLen = (char) ByteUtil.getBytesByString(apSsid).length;
    // hostname parse
    String ipAddrStrs[] = ipAddress.getHostAddress().split(&quot;\\.&quot;);
    int ipLen = ipAddrStrs.length;

    char ipAddrChars[] = new char[ipLen];
    // only support ipv4 at the moment
    for (int i = 0; i &lt; ipLen; ++i) {
        ipAddrChars[i] = (char) Integer.parseInt(ipAddrStrs[i]);
    }


    char _totalLen = (char) (EXTRA_HEAD_LEN + ipLen + apPwdLen + apSsidLen);
    char totalLen = isSsidHiden ? (char) (EXTRA_HEAD_LEN + ipLen + apPwdLen + apSsidLen)
            : (char) (EXTRA_HEAD_LEN + ipLen + apPwdLen);

    // build data codes
    mDataCodes = new DataCode[totalLen];
    mDataCodes[0] = new DataCode(_totalLen, 0);
    totalXor ^= _totalLen;
    mDataCodes[1] = new DataCode(apPwdLen, 1);
    totalXor ^= apPwdLen;
    mDataCodes[2] = new DataCode(apSsidCrc, 2);
    totalXor ^= apSsidCrc;
    mDataCodes[3] = new DataCode(apBssidCrc, 3);
    totalXor ^= apBssidCrc;
    mDataCodes[4] = null;
    for (int i = 0; i &lt; ipLen; ++i) {
        mDataCodes[i + EXTRA_HEAD_LEN] = new DataCode(ipAddrChars[i], i + EXTRA_HEAD_LEN);
        totalXor ^= ipAddrChars[i];
    }

    byte[] apPwdBytes = ByteUtil.getBytesByString(apPassword);
    char[] apPwdChars = new char[apPwdBytes.length];
    for (int i = 0;i &lt; apPwdBytes.length; i++) {
        apPwdChars[i] = ByteUtil.convertByte2Uint8(apPwdBytes[i]);
    }
    for (int i = 0; i &lt; apPwdChars.length; i++) {
        mDataCodes[i + EXTRA_HEAD_LEN + ipLen] = new DataCode(
                apPwdChars[i], i + EXTRA_HEAD_LEN + ipLen);
        totalXor ^= apPwdChars[i];
    }

    byte[] apSsidBytes = ByteUtil.getBytesByString(apSsid);
    char[] apSsidChars = new char[apSsidBytes.length];

    // totalXor will xor apSsidChars no matter whether the ssid is hidden
    for (int i = 0; i &lt; apSsidBytes.length; i++) {
        apSsidChars[i] = ByteUtil.convertByte2Uint8(apSsidBytes[i]);
        totalXor ^= apSsidChars[i];
    }

    if (isSsidHiden) {
        for (int i = 0; i &lt; apSsidChars.length; i++) {
            mDataCodes[i + EXTRA_HEAD_LEN + ipLen + apPwdLen] = new DataCode(
                    apSsidChars[i], i + EXTRA_HEAD_LEN + ipLen + apPwdLen);
        }
    }

    // set total xor last
    mDataCodes[4] = new DataCode(totalXor, 4);
}
</code></pre><h2 id="下面的是一个关键性方法-listenAsyn-mParameter-getEsptouchResultTotalLen"><a href="#下面的是一个关键性方法-listenAsyn-mParameter-getEsptouchResultTotalLen" class="headerlink" title="下面的是一个关键性方法__listenAsyn(mParameter.getEsptouchResultTotalLen());"></a>下面的是一个关键性方法__listenAsyn(mParameter.getEsptouchResultTotalLen());</h2><p><strong>listenAsyn(mParameter.getEsptouchResultTotalLen());实质就是</strong>listenAsyn(11);</p>
<pre><code>private void __listenAsyn(final int expectDataLen) { //11
    new Thread() {
        public void run() {

            long startTimestamp = System.currentTimeMillis();//获取系统当前时间

            byte[] apSsidAndPassword = ByteUtil.getBytesByString(mApSsid
                    + mApPassword); //return string.getBytes(ESPTOUCH_ENCODING_CHARSET);  转化为utf-8的格式

            byte expectOneByte = (byte) (apSsidAndPassword.length + 9); // 看一下子期望的字节


            byte receiveOneByte = -1;    // 接收的字节
            byte[] receiveBytes = null; // 接收的字节数组
            while (mEsptouchResultList.size() &lt; mParameter
                    .getExpectTaskResultCount() &amp;&amp; !mIsInterrupt) {

                receiveBytes = mSocketServer
                        .receiveSpecLenBytes(expectDataLen);  //  接收特定的特殊的字符  11

                if (receiveBytes != null) {

                    receiveOneByte = receiveBytes[0];

                } else {
                    receiveOneByte = -1;
                }
            // 接收到的字节和期望的字节一致
                if (receiveOneByte == expectOneByte) {
                    if (__IEsptouchTask.DEBUG) {
                        Log.i(TAG, &quot;receive correct broadcast&quot;);
                    }
                    // change the socket&apos;s timeout
                    long consume = System.currentTimeMillis()
                            - startTimestamp;  // 当前的异步的时间减去开始异步监听的系统时间
                    int timeout = (int) (mParameter
                            .getWaitUdpTotalMillisecond() - consume); // 60000-consume
                    if (timeout &lt; 0) {  // 超时
                        if (__IEsptouchTask.DEBUG) {
                            Log.i(TAG, &quot;esptouch timeout&quot;);
                        }
                        break;
                    } else { // 没有超时

                        if (__IEsptouchTask.DEBUG) {
                            Log.i(TAG, &quot;mSocketServer&apos;s new timeout is &quot;
                                    + timeout + &quot; milliseconds&quot;);
                        }

                        mSocketServer.setSoTimeout(timeout);

                        if (__IEsptouchTask.DEBUG) {
                            Log.i(TAG, &quot;receive correct broadcast&quot;);
                        }
                        if (receiveBytes != null) {

                            String bssid = ByteUtil.parseBssid( // 解析获取的设备ssid
                                    receiveBytes,
                                    mParameter.getEsptouchResultOneLen(), // 查询是1
                                    mParameter.getEsptouchResultMacLen()); //查询是6
                            InetAddress inetAddress = EspNetUtil  // 解析获取的设备的 ip地址
                                    .parseInetAddr(
                                            receiveBytes,
                                            mParameter.getEsptouchResultOneLen() //1
                                            + mParameter.getEsptouchResultMacLen(), //6
                                            mParameter.getEsptouchResultIpLen());//4

                            __putEsptouchResult(true, bssid, inetAddress);  // 存放到集合
                        }
                    }
                } else {
                    if (__IEsptouchTask.DEBUG) {
                        Log.i(TAG, &quot;receive rubbish message, just ignore&quot;);
                    }
                }
            }
            mIsSuc = mEsptouchResultList.size() &gt;= mParameter
                    .getExpectTaskResultCount();  // size和1比较
            __EsptouchTask.this.__interrupt();// 打断
            if (__IEsptouchTask.DEBUG) {
                Log.d(TAG, &quot;__listenAsyn() finish&quot;);
            }
        }
    }.start();
}
</code></pre><p>首先是这个方法里面又开了一个子线程来运行程序:其他的都直接在程序中说明:</p>
<p>我们看看存放的方法 __putEsptouchResult():</p>
<pre><code>private void __putEsptouchResult(boolean isSuc, String bssid,
        InetAddress inetAddress) {
    synchronized (mEsptouchResultList) {
        // check whether the result receive enough UDP response
        boolean isTaskSucCountEnough = false;
        Integer count = mBssidTaskSucCountMap.get(bssid);// map结合根据bssid获取 count
        if (count == null) {
            count = 0;
        }
        ++count;
        if (__IEsptouchTask.DEBUG) {
            Log.d(TAG, &quot;__putEsptouchResult(): count = &quot; + count);
        }
        mBssidTaskSucCountMap.put(bssid, count); //  存放到集合中
        isTaskSucCountEnough = count &gt;= mParameter
                .getThresholdSucBroadcastCount();  // 将count和1比较
        if (!isTaskSucCountEnough) {
            if (__IEsptouchTask.DEBUG) {
                Log.d(TAG, &quot;__putEsptouchResult(): count = &quot; + count
                        + &quot;, isn&apos;t enough&quot;);
            }
            return;
        }
        // check whether the result is in the mEsptouchResultList already 检查是否存在
        boolean isExist = false;
        for (IEsptouchResult esptouchResultInList : mEsptouchResultList) {
            if (esptouchResultInList.getBssid().equals(bssid)) {
                isExist = true;
                break;
            }
        }
        // only add the result who isn&apos;t in the mEsptouchResultList
        if (!isExist) { // 不存在,new一个 EsptouchResult并进行复制,走到这一步就是成功的,后面有失败的处理,失败集合就是null的.
            if (__IEsptouchTask.DEBUG) {
                Log.d(TAG, &quot;__putEsptouchResult(): put one more result&quot;);
            }
            final IEsptouchResult esptouchResult = new EsptouchResult(isSuc,
                    bssid, inetAddress);

            mEsptouchResultList.add(esptouchResult);
            if (mEsptouchListener != null) {
                mEsptouchListener.onEsptouchResultAdded(esptouchResult);
            }
        }
    }
}
</code></pre><p>我们看完继续看:__execute(generator);</p>
<pre><code>isSuc = __execute(generator);  //  这个方法中会去发送数据包

private boolean __execute(IEsptouchGenerator generator) {

    long startTime = System.currentTimeMillis();
    long currentTime = startTime;
    long lastTime = currentTime - mParameter.getTimeoutTotalCodeMillisecond();// 6000 (不是60000)

    byte[][] gcBytes2 = generator.getGCBytes2();
    byte[][] dcBytes2 = generator.getDCBytes2();

    int index = 0;
    while (!mIsInterrupt) {
        if (currentTime - lastTime &gt;= mParameter.getTimeoutTotalCodeMillisecond()) { // 6000
            if (__IEsptouchTask.DEBUG) {
                Log.d(TAG, &quot;send gc code &quot;);
            }
            // send guide code
            while (!mIsInterrupt
                    &amp;&amp; System.currentTimeMillis() - currentTime &lt; mParameter
                            .getTimeoutGuideCodeMillisecond()) { //6000

                //  也是一个发送数据的地方
                mSocketClient.sendData(gcBytes2,
                        mParameter.getTargetHostname(),
                        mParameter.getTargetPort(),
                        mParameter.getIntervalGuideCodeMillisecond());

                // check whether the udp is send enough time
                if (System.currentTimeMillis() - startTime &gt; mParameter.getWaitUdpSendingMillisecond()) {
                    break;
                }
            }
            lastTime = currentTime;
        } else {
            //   发送数据报文

            mSocketClient.sendData(dcBytes2, index, ONE_DATA_LEN,
                    mParameter.getTargetHostname(), //234.1.1.1, 234.2.2.2, 234.3.3.3 to 234.100.100.100
                    mParameter.getTargetPort(), //7001
                    mParameter.getIntervalDataCodeMillisecond());  // 10
            index = (index + ONE_DATA_LEN) % dcBytes2.length;  // (index+3)%dcBytes2.length;
        }
        currentTime = System.currentTimeMillis();
        // check whether the udp is send enough time
        if (currentTime - startTime &gt; mParameter.getWaitUdpSendingMillisecond()) {
            break;
        }
    }

    return mIsSuc;
}
</code></pre><p>我们来看看具体的发送的发送的hostname:</p>
<pre><code>// target hostname is : 234.1.1.1, 234.2.2.2, 234.3.3.3 to 234.100.100.100
@Override
public String getTargetHostname() {

    int count = __getNextDatagramCount();
    return &quot;234.&quot; + count + &quot;.&quot; + count + &quot;.&quot; + count;
}
</code></pre><p>还差最后一点方法:executeForResults(1)</p>
<pre><code>if (isSuc) {
            return __getEsptouchResultList();
        }
</code></pre><p>上面返回的 isSUC的值为true </p>
<p>获取__getEsptouchResultList();</p>
<pre><code>private List&lt;IEsptouchResult&gt; __getEsptouchResultList() {
    synchronized (mEsptouchResultList) {
        if (mEsptouchResultList.isEmpty()) { // 失败的结果,也返回这不过返回的就是 false 和null null
            EsptouchResult esptouchResultFail = new EsptouchResult(false,
                    null, null);
            esptouchResultFail.setIsCancelled(mIsCancelled.get());
            mEsptouchResultList.add(esptouchResultFail);
        }

        return mEsptouchResultList;
    }
}
</code></pre><p>整体的过程结束.我们查看查看,发送数据那一段:</p>
<p>IEsptouchGenerator generator = new EsptouchGenerator(mApSsid, mApBssid,<br>                mApPassword, localInetAddress, mIsSsidHidden);<br>开始说起:</p>
<pre><code>public EsptouchGenerator(String apSsid, String apBssid, String apPassword,
        InetAddress inetAddress, boolean isSsidHiden) {
    // generate guide code
    GuideCode gc = new GuideCode();
    char[] gcU81 = gc.getU8s();// 获取的就是 515 514 5123 512
    mGcBytes2 = new byte[gcU81.length][];// 创建数组

    for (int i = 0; i &lt; mGcBytes2.length; i++) {
        mGcBytes2[i] = ByteUtil.genSpecBytes(gcU81[i]);
    }

    // generate data code
    DatumCode dc = new DatumCode(apSsid, apBssid, apPassword, inetAddress,
            isSsidHiden);
    char[] dcU81 = dc.getU8s();
    mDcBytes2 = new byte[dcU81.length][];

    for (int i = 0; i &lt; mDcBytes2.length; i++) {
        mDcBytes2[i] = ByteUtil.genSpecBytes(dcU81[i]); // 注意的是 图片显示的是0123 ,表示的是下表,是一个二维数组
    }
}
</code></pre><p>我们再来看看:GuideCode</p>
<p>源代码如下:</p>
<pre><code>public class GuideCode implements ICodeData {

public static final int GUIDE_CODE_LEN = 4;

@Override
public byte[] getBytes() {
    throw new RuntimeException(&quot;DataCode don&apos;t support getBytes()&quot;);
}

@Override
public String toString() {
    StringBuilder sb = new StringBuilder();
    char[] dataU8s = getU8s();
    for (int i = 0; i &lt; GUIDE_CODE_LEN; i++) {
        String hexString = ByteUtil.convertU8ToHexString(dataU8s[i]);
        sb.append(&quot;0x&quot;);
        if (hexString.length() == 1) {
            sb.append(&quot;0&quot;);
        }
        sb.append(hexString).append(&quot; &quot;);
    }
    return sb.toString();
}

@Override
public char[] getU8s() {
    char[] guidesU8s = new char[GUIDE_CODE_LEN];
    guidesU8s[0] = 515;
    guidesU8s[1] = 514;
    guidesU8s[2] = 513;
    guidesU8s[3] = 512;
    return guidesU8s;
}
}
</code></pre><p>解释如下:</p>
<p>实现的接口代码:</p>
<pre><code>byte[] getBytes();  //Get the byte[] to be transformed.
char[] getU8s(); //Get the char[](u8[]) to be transfromed.
</code></pre><p>我们看看实现的过程,字节直接是一个空方法,下面看getU8s()数组中分别开始赋值 515到512,tostring()的操作: 最后的结果如下:</p>
<pre><code>//  dubug的测试的最后结果是: 0x203 0x202 0x201 0x200   注意前面的ox是直接添加的
</code></pre><p>我们继续看DatumCode类:</p>
<p><img src="http://i.imgur.com/suC35bU.jpg" alt=""></p>
<p>就这样吧!</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[this is new page hello world]]></title>
      <url>/2018/01/08/this-is-new-page-hello-world/</url>
      <content type="html"><![CDATA[<h1 id="我们实际测试的页面"><a href="#我们实际测试的页面" class="headerlink" title="我们实际测试的页面"></a>我们实际测试的页面</h1><p>开启评论的设置,于七分是自己的一个idea,曾经在回想着全身心的付出就是对你最好的回应,抛掉过往,和那些我所不能偿还的人们说清楚,认真二字我估计是他们对我信心的认可,只是于七分,太满会溢出.于七分,三分给自己,自爱(爱护身体),自息(天行健君子以自强不息,地势坤君子以厚德载物),自强(提高自己,不断的学习),坚持(毅力和执行力).<br><a id="more"></a></p>
<p>comments  设置为true 就可以了!</p>
<p>设置阅读更多的操作:</p>
<p>方式有三种:</p>
<ol>
<li>第一种是使用 <!--more--> 之歌标志之前的会作为简介来展现,出现点击阅读全文的字样.</li>
<li>在文章的 front-matter 中添加description,,,,,,具体的格式是如下:  <code>description: 这是我要展示的简介文字</code></li>
<li><p>第三个就是 配置主题文件的配置文件 </p>
<p> auto_excerpt”<br>   enable: true<br>   length: 150(表示截取的长度是150字符,也是默认的)</p>
</li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 随笔 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
